[
  {
    "id": "ClassFraction",
    "label": "Class fraction layer from categorized vector layer",
    "version": "3.10",
    "description": "Rasterize a categorized vector layer into class fractions. Categories are rasterized at a x10 finer resolution and aggregated to class-wise fractions at destination resolution. This approach leads to fractions that are accurate to the percent.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "(C) 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ClassFraction",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ClassFraction",
        "name": "outputFraction",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "fractions_polygons.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "categorizedVector",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A categorized vector layer to be rasterized.",
        "label": "categorized vector",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "grid",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Grid",
        "label": "grid",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ClassFractionLayerFromCategorizedVectorLayer\ncategorizedVector=$categorizedVector\ngrid=$grid\noutputFraction=$outputFraction"
  },
  {
    "id": "Classification4Simple",
    "label": "Classification layer accuracy and area report (for simple random sampling)",
    "version": "3.10",
    "description": "Estimates map accuracy and area proportions for (simple) random sampling. We use the formulars for the stratified random sampling described in Stehman (2014): https://doi.org/10.1080/01431161.2014.930207. Note that (simple) random sampling is a special case of stratified random sampling, with exactly one stratum. Observed and predicted categories are matched by name.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "(C) 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "Classification4Simple",
        "name": "classification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "Classification4Simple",
        "name": "reference",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "Classification4Simple",
        "name": "outClassificationPerformance",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "report.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:ClassificationLayerAccuracyAndAreaReportForSimpleRandomSampling\nclassification=$classification\nreference=$reference\nopenReport=false\noutClassificationPerformance=$outClassificationPerformance"
  },
  {
    "id": "Classification4Stratified",
    "label": "Classification layer accuracy and area report (for stratified random sampling)",
    "version": "3.10",
    "description": "Estimates map accuracy and area proportions for stratified random sampling as described in Stehman (2014): https://doi.org/10.1080/01431161.2014.930207. Observed and predicted categories are matched by name.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "Classification4Stratified",
        "name": "classification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "Classification4Stratified",
        "name": "reference",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "Classification4Stratified",
        "name": "stratification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "Classification4Stratified",
        "name": "outClassificationPerformance",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "report.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:ClassificationLayerAccuracyAndAreaReportForStratifiedRandomSampling\nclassification=$classification\nreference=$reference\nstratification=$stratification\nopenReport=false\noutClassificationPerformance=$outClassificationPerformance"
  },
  {
    "id": "ClassificationFraction",
    "label": "Classification layer from class probability/fraction layer",
    "version": "3.10",
    "description": "Creates classification layer from class probability layer or class fraction layer. Winner class is given by the class with maximum class probabiliy/fraction.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ClassificationFraction",
        "name": "probability",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ClassificationFraction",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "classification.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:ClassificationLayerFromClassProbabilityfractionLayer\nprobability=$probability\noutputClassification=$outputClassification"
  },
  {
    "id": "ClassificationWorkflow",
    "label": "Classification workflow",
    "version": "3.10",
    "description": "The classification workflow combines classifier fitting, map prediction and accuracy assessment.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ClassificationWorkflow",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ClassificationWorkflow",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "classification.tif"
        }
      },
      {
        "id": null,
        "parentId": "ClassificationWorkflow",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "classification.tif"
        }
      },
      {
        "id": null,
        "parentId": "ClassificationWorkflow",
        "name": "outputProbability",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "probability.tif"
        }
      },
      {
        "id": null,
        "parentId": "ClassificationWorkflow",
        "name": "outputClassifierPerformance",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "report.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Scikit-Learn Python code specifying a classifier",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "raster",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A raster layer with bands used as features",
        "label": "raster",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "nfold",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 10,
        "description": "The number of folds used for assessing cross-validation performance",
        "label": "nfold",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ClassificationWorkflow\ndataset=$dataset\nclassifier=$classifier\nraster=$raster\nnfold=$nfold\nopenReport=false\noutputClassifier=$outputClassifier\noutputClassification=$outputClassification\noutputProbability=$outputProbability\noutputClassifierPerformance=$outputClassifierPerformance"
  },
  {
    "id": "ClassifierPerformanceReport",
    "label": "Classifier performance report",
    "version": "3.10",
    "description": "Evaluates classifier performance.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ClassifierPerformanceReport",
        "name": "classifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "ClassifierPerformanceReport",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ClassifierPerformanceReport",
        "name": "outputClassifierPerformance",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "report.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "nfold",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "The number of folds used for assessing cross-validation performance. If not specified (default), simple test performance is assessed.",
        "label": "nfold",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ClassifierPerformanceReport\nclassifier=$classifier\ndataset=$dataset\nnfold=$nfold\nopenReport=false\noutputClassifierPerformance=$outputClassifierPerformance"
  },
  {
    "id": "FitCatBoostClassifier",
    "label": "Fit CatBoostClassifier",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for CatBoost classifier.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitCatBoostClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitCatBoostClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from catboost import CatBoostClassifier;classifier = CatBoostClassifier(train_dir='/mnt/enmap/output/',n_estimators=100)",
        "description": "Scikit-learn python code. See CatBoostClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitCatboostclassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitGaussianProcessClassifier",
    "label": "Fit GaussianProcessClassifier",
    "version": "3.10",
    "description": "Gaussian process classification (GPC) based on Laplace approximation. The implementation is based on Algorithm 3.1, 3.2, and 5.1 of Gaussian Processes for Machine Learning (GPML) by Rasmussen and Williams. Internally, the Laplace approximation is used for approximating the non-Gaussian posterior by a Gaussian. Currently, the implementation is restricted to using the logistic link function. For multi-class classification, several binary one-versus rest classifiers are fitted. Note that this class thus does not implement a true multi-class Laplace approximation. See Gaussian Processes for further information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitGaussianProcessClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitGaussianProcessClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.preprocessing import StandardScaler; from sklearn.gaussian_process import GaussianProcessClassifier; from sklearn.gaussian_process.kernels import RBF; gpc = GaussianProcessClassifier(RBF(), max_iter_predict=1); classifier = make_pipeline(StandardScaler(), gpc)",
        "description": "Scikit-learn python code. See GaussianProcessClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitGaussianprocessclassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitGenericClassifier",
    "label": "Fit generic classifier",
    "version": "3.10",
    "description": "A generic classifier.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitGenericClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitGenericClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.dummy import DummyClassifier; classifier = DummyClassifier()",
        "description": "Scikit-learn python code.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitGenericClassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitLGBMClassifier",
    "label": "Fit LGBM Classifier",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for LightGBM classifier.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLGBMClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLGBMClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from lightgbm import LGBMClassifier; classifier = LGBMClassifier(n_estimators=100)",
        "description": "Scikit-learn python code. See LGBMClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLgbmclassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitLinearSVC",
    "label": "Fit Linear SVC",
    "version": "3.10",
    "description": "Linear Support Vector Classification. Similar to SVC with parameter kernel=’linear’, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples. This class supports both dense and sparse input and the multiclass support is handled according to a one-vs-the-rest scheme.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLinearSVC",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLinearSVC",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.model_selection import GridSearchCV; from sklearn.preprocessing import StandardScaler; from sklearn.svm import LinearSVC; svc = LinearSVC(); param_grid = {'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]}; tunedSVC = GridSearchCV(cv=3, estimator=svc, scoring='f1_macro', param_grid=param_grid); classifier = make_pipeline(StandardScaler(), tunedSVC)",
        "description": "Scikit-learn python code. See LinearSVC, GridSearchCV, StandardScaler for information on different parameters.",
        "label": "classifier",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLinearsvc\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitLogisticRegression",
    "label": "Fit Logistic Regression",
    "version": "3.10",
    "description": "Logistic Regression (aka logit, MaxEnt) classifier. In the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme if the ‘multi_class’ option is set to ‘ovr’, and uses the cross-entropy loss if the ‘multi_class’ option is set to ‘multinomial’.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLogisticRegression",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLogisticRegression",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.linear_model import LogisticRegression; from sklearn.preprocessing import StandardScaler; from sklearn.pipeline import make_pipeline; logisticRegression = LogisticRegression(); classifier = make_pipeline(StandardScaler(), logisticRegression)",
        "description": "Scikit-learn python code. See LogisticRegression for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLogisticregression\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitRandomForestClassifier",
    "label": "Fit Random Forest Classifier",
    "version": "3.10",
    "description": "A random forest classifier. A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. The sub-sample size is controlled with the max_samples parameter if bootstrap=True (default), otherwise the whole dataset is used to build each tree.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitRandomForestClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitRandomForestClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.ensemble import RandomForestClassifier; classifier = RandomForestClassifier(n_estimators=100, oob_score=True)",
        "description": "Scikit-learn python code. See RandomForestClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitRandomforestclassifier4Modeler\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitSpectralAngleMapper",
    "label": "Fit Spectral Angle Mapper",
    "version": "3.10",
    "description": "from sklearn.ensemble import RandomForestClassifier; classifier = RandomForestClassifier(n_estimators=100, oob_score=True)",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitSpectralAngleMapper",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitSpectralAngleMapper",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier ",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.preprocessing import Normalizer; from sklearn.neighbors import KNeighborsClassifier; classifier = make_pipeline(Normalizer(), KNeighborsClassifier(n_neighbors=1))",
        "description": "Training dataset pickle file used for fitting the classifier. If not specified, an unfitted classifier is created.",
        "label": "classifier ",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitSpectralanglemapper\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitSVCPolynomialKernel",
    "label": "Fit SVC (polynomial kernel)",
    "version": "3.10",
    "description": "C-Support Vector Classification. The implementation is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. The multiclass support is handled according to a one-vs-one scheme.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitSVCPolynomialKernel",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitSVCPolynomialKernel",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.model_selection import GridSearchCV; from sklearn.preprocessing import StandardScaler; from sklearn.svm import SVC; svc = SVC(probability=False); param_grid = {'kernel': ['poly'], 'coef0': [0], 'degree': [3], 'gamma': [0.001, 0.01, 0.1, 1, 10, 100, 1000], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]}; tunedSVC = GridSearchCV(cv=3, estimator=svc, scoring='f1_macro', param_grid=param_grid); classifier = make_pipeline(StandardScaler(), tunedSVC)",
        "description": "Scikit-learn python code. See SVC, GridSearchCV, StandardScaler for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitSvcPolynomialKernel\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitSVCRBFKernel",
    "label": "Fit SVC (RBF kernel)",
    "version": "3.10",
    "description": "C-Support Vector Classification. The implementation is based on libsvm. The fit time scales at least quadratically with the number of samples and may be impractical beyond tens of thousands of samples. The multiclass support is handled according to a one-vs-one scheme.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitSVCRBFKernel",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitSVCRBFKernel",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.model_selection import GridSearchCV; from sklearn.preprocessing import StandardScaler; from sklearn.svm import SVC; svc = SVC(probability=False); param_grid = {'kernel': ['rbf'], 'gamma': [0.001, 0.01, 0.1, 1, 10, 100, 1000], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]}; tunedSVC = GridSearchCV(cv=3, estimator=svc, scoring='f1_macro', param_grid=param_grid); classifier = make_pipeline(StandardScaler(), tunedSVC)",
        "description": "Scikit-learn python code. See SVC, GridSearchCV, StandardScaler for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitSvcRbfKernel\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitXGBClassifier",
    "label": "Fit XGB Classifier",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for XGBoost classification.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitXGBClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitXGBClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from xgboost import XGBClassifier; classifier = XGBClassifier(n_estimators=100)",
        "description": "Scikit-learn python code. See XGBClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitXgbclassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "FitXGBRFClassifier",
    "label": "Fit XGBRF Classifier",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for XGBoost random forest classification.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitXGBRFClassifier",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitXGBRFClassifier",
        "name": "outputClassifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "classifier",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from xgboost import XGBRFClassifier; classifier = XGBRFClassifier(n_estimators=100)",
        "description": "Scikit-learn python code. See XGBRFClassifier for information on different parameters.",
        "label": "classifier",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitXgbrfclassifier\nclassifier=$classifier\ndataset=$dataset\noutputClassifier=$outputClassifier"
  },
  {
    "id": "PredictClassProbability",
    "label": "Predict class probability layer",
    "version": "3.10",
    "description": "Uses a fitted classifier to predict class probability layer from a raster layer with features.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "PredictClassProbability",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "PredictClassProbability",
        "name": "classifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "PredictClassProbability",
        "name": "outputProbability",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_probability.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:PredictClassProbabilityLayer\nraster=$raster\nclassifier=$classifier\noutputProbability=$outputProbability"
  },
  {
    "id": "PredictClassification",
    "label": "Predict classification layer",
    "version": "3.10",
    "description": "Uses a fitted classifier to predict a classification layer from a raster layer with features. Used in the Cookbook Recipes: Classification, Graphical Modeler for information on different parameters.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "PredictClassification",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "PredictClassification",
        "name": "classifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "PredictClassification",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_probability.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:PredictClassificationLayer\nraster=$raster\nclassifier=$classifier\noutputClassification=$outputClassification"
  },
  {
    "id": "ReclassifyRaster",
    "label": "Reclassify raster layer",
    "version": "3.10",
    "description": "This algorithm reclassifies a raster by assigning new class values based on a class mapping.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ReclassifyRaster",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ReclassifyRaster",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_classification.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "mapping",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A list of source to target class value mappings. E.g. to merge source values 1 and 2 into target value 1, and source values 3 and 4 into target value 2, use {1:1, 2:1, 3:2, 4:2}",
        "label": "mapping",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "categories",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A list of target categories in short notation: [(1, ‘Class A’, ‘#e60000’), (2, ‘Class B’, ‘#267300’)]",
        "label": "categories",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "noDataValue",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Value used to fill no data regions.",
        "label": "noDataValue",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ReclassifyRasterLayer\nraster=$raster\nmapping=$mapping\ncategories=$categories\nnoDataValue=$noDataValue\noutputClassification=$outputClassification"
  },
  {
    "id": "FitAffinityPropagation",
    "label": "Fit AffinityPropagation",
    "version": "3.10",
    "description": "Perform Affinity Propagation Clustering.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitAffinityPropagation",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitAffinityPropagation",
        "name": "outputClusterer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_clusterer.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "clusterer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.preprocessing import StandardScaler; from sklearn.cluster import AffinityPropagation; affinityPropagation = AffinityPropagation(); clusterer = make_pipeline(StandardScaler(), affinityPropagation)",
        "description": "Scikit-learn python code. See AffinityPropagation for information on different parameters.",
        "label": "clusterer",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitAffinitypropagation\nclusterer=$clusterer\ndataset=$dataset\noutputClusterer=$outputClusterer"
  },
  {
    "id": "FitBirch",
    "label": "Fit Birch",
    "version": "3.10",
    "description": "Implements the BIRCH clustering algorithm. It is a memory-efficient, online-learning algorithm provided as an alternative to MiniBatchKMeans. It constructs a tree data structure with the cluster centroids being read off the leaf. These can be either the final cluster centroids or can be provided as input to another clustering algorithm such as AgglomerativeClustering.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitBirch",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitBirch",
        "name": "outputClusterer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_clusterer.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "clusterer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.preprocessing import StandardScaler; from sklearn.cluster import Birch; birch = Birch(n_clusters=3); clusterer = make_pipeline(StandardScaler(), birch)",
        "description": "Scikit-learn python code. See Birch for information on different parameters.",
        "label": "clusterer",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitBirch\nclusterer=$clusterer\ndataset=$dataset\noutputClusterer=$outputClusterer"
  },
  {
    "id": "FitKMeans",
    "label": "Fit KMeans",
    "version": "3.10",
    "description": "",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitKMeans",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitKMeans",
        "name": "outputClusterer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_clusterer.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "clusterer ",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.cluster import KMeans; clusterer = KMeans(n_clusters=8)",
        "description": "Scikit-learn python code. See KMeans for information on different parameters.",
        "label": "clusterer ",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitKmeans\nclusterer=$clusterer\ndataset=$dataset\noutputClusterer=$outputClusterer"
  },
  {
    "id": "FitMeanshift",
    "label": "Fit Mean Shift",
    "version": "3.10",
    "description": "Mean shift clustering using a flat kernel. Mean shift clustering aims to discover 'blobs' in a smooth density of samples. It is a centroid-based algorithm, which works by updating candidates for centroids to be the mean of the points within a given region. These candidates are then filtered in a post-processing stage to eliminate near-duplicates to form the final set of centroids. Seeding is performed using a binning technique for scalability.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitMeanshift",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitMeanshift",
        "name": "outputClusterer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_clusterer.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "clusterer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline; from sklearn.preprocessing import StandardScaler; from sklearn.cluster import MeanShift; meanShift = MeanShift(); clusterer = make_pipeline(StandardScaler(), meanShift)",
        "description": "Scikit-learn python code. See MeanShift for information on different parameters.",
        "label": "clusterer",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitMeanshift\nclusterer=$clusterer\ndataset=$dataset\noutputClusterer=$outputClusterer"
  },
  {
    "id": "PredictUnsupervisedClassification",
    "label": "Predict (unsupervised) classification layer",
    "version": "3.10",
    "description": "Uses a fitted clusterer to predict an (unsupervised) classification layer from a raster layer with features.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "PredictUnsupervisedClassification",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "PredictUnsupervisedClassification",
        "name": "clusterer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "PredictUnsupervisedClassification",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output_classification.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:PredictUnsupervisedClassificationLayer\nraster=$raster\nclusterer=$clusterer\noutputClassification=$outputClassification"
  },
  {
    "id": "SpatialConvolutionAiryDisk",
    "label": "Spatial convolution Airy Disk filter",
    "version": "3.10",
    "description": "2D Airy Disk filter. This kernel models the diffraction pattern of a circular aperture. This kernel is normalized to a peak value of 1",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionAiryDisk",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionAiryDisk",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See AiryDisk2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionAiryDiskFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionBox",
    "label": "Spatial convolution Box filter",
    "version": "3.10",
    "description": "2D Box filter. The Box filter or running mean is a smoothing filter. It is not isotropic and can produce artifact, when applied repeatedly to the same data.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionBox",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionBox",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionBoxFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionCustom",
    "label": "Spatial convolution custom filter",
    "version": "3.10",
    "description": "Create a spatial 2D filter kernel from list or array.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionCustom",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionCustom",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionCustomFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionGaussian",
    "label": "Spatial convolution Gaussian filter",
    "version": "3.10",
    "description": "2D Gaussian filter. The Gaussian filter is a filter with great smoothing properties. It is isotropic and does not produce artifacts.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionGaussian",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionGaussian",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionGaussianFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionMoffat",
    "label": "Spatial convolution Moffat filter",
    "version": "3.10",
    "description": "2D Moffat filter. This kernel is a typical model for a seeing limited PSF.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionMoffat",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionMoffat",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionMoffatFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionRickerWavelet",
    "label": "Spatial convolution Ricker Wavelet filter",
    "version": "3.10",
    "description": "2D Ricker Wavelet filter kernel (sometimes known as a Mexican Hat kernel). The Ricker Wavelet, or inverted Gaussian-Laplace filter, is a bandpass filter. It smooths the data and removes slowly varying or constant structures (e.g. background). It is useful for peak or multi-scale detection.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionRickerWavelet",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionRickerWavelet",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionRickerWaveletFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionRing",
    "label": "Spatial convolution ring filter",
    "version": "3.10",
    "description": "2D Ring filter. The Ring filter kernel is the difference between two Top-Hat kernels of different width. This kernel is useful for, e.g., background estimation.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionRing",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionRing",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionRingFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionSavitskyGolay",
    "label": "Spatial convolution Savitsky-Golay filter",
    "version": "3.10",
    "description": "2D Savitsky-Golay filter. See wikipedia for details.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionSavitskyGolay",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionSavitskyGolay",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionSavitskygolayFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionTopHat",
    "label": "Spatial convolution Top-Hat filter",
    "version": "3.10",
    "description": "2D Top-Hat filter. The Top-Hat filter is an isotropic smoothing filter. It can produce artifacts when applied repeatedly on the same data.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionTopHat",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionTopHat",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionTophatFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialConvolutionTrapezoid",
    "label": "Spatial convolution Trapezoid filter",
    "version": "3.10",
    "description": "2D Trapezoid filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialConvolutionTrapezoid",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialConvolutionTrapezoid",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialConvolutionTrapezoidFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialGaussianGradientMagnitude",
    "label": "Spatial Gaussian Gradient Magnitude filter",
    "version": "3.10",
    "description": "Spatial Gaussian Gradient Magnitude filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialGaussianGradientMagnitude",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialGaussianGradientMagnitude",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "filtered.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See gaussian_gradient_magnitude for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialGaussianGradientMagnitudeFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialGeneric",
    "label": "Spatial generic filter",
    "version": "3.10",
    "description": "Spatial generic (user-defined) filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialGeneric",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialGeneric",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See generic_filter for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialGenericFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialLaplace",
    "label": "Spatial Laplace filter",
    "version": "3.10",
    "description": "Spatial Laplace filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialLaplace",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialLaplace",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See laplace for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialLaplaceFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMaximum",
    "label": "Spatial Maximum filter",
    "version": "3.10",
    "description": "",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMaximum",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMaximum",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See maximum_filter for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMaximumFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMedian",
    "label": "Spatial Median filter",
    "version": "3.10",
    "description": "Spatial Median filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMedian",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMedian",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See median_filter for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMedianFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMinimum",
    "label": "Spatial Minimum filter",
    "version": "3.10",
    "description": "Spatial Minimum filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMinimum",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMinimum",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See minimum_filter for information on different parameters.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMinimumFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryClosing",
    "label": "Spatial morphological Binary Closing filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Closing filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryClosing",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryClosing",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryClosingFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryDilation",
    "label": "Spatial morphological Binary Dilation filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Dilation filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryDilation",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryDilation",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryDilationFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryErosion",
    "label": "Spatial morphological Binary Erosion filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Erosion filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryErosion",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryErosion",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryErosionFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryFillHoles",
    "label": "Spatial morphological Binary Fill Holes filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Fill Holes filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryFillHoles",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryFillHoles",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryFillHolesFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryOpening",
    "label": "Spatial morphological Binary Opening filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Opening filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryOpening",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryOpening",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryOpeningFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBinaryPropagation",
    "label": "Spatial morphological Binary Propagation filter",
    "version": "3.10",
    "description": "Spatial morphological Binary Propagation filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryPropagation",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBinaryPropagation",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBinaryPropagationFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalBlackTopHat",
    "label": "Spatial morphological Black Top-Hat filter",
    "version": "3.10",
    "description": "Spatial morphological Black Top-Hat filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBlackTopHat",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalBlackTopHat",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalBlackTophatFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalGradient",
    "label": "Spatial morphological Gradient filter",
    "version": "3.10",
    "description": "Spatial morphological Gradient filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGradient",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGradient",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalGradientFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalGreyDilation",
    "label": "Spatial morphological Grey Dilation filter",
    "version": "3.10",
    "description": "Spatial morphological Grey Dilation filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyDilation",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyDilation",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalGreyDilationFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalGreyErosion",
    "label": "Spatial morphological Grey Erosion filter",
    "version": "3.10",
    "description": "Spatial morphological Grey Erosion filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyErosion",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyErosion",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalGreyErosionFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalGreyOpening",
    "label": "Spatial morphological Grey Opening filter",
    "version": "3.10",
    "description": "Spatial morphological Grey Opening filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyOpening",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalGreyOpening",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalGreyOpeningFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalLaplace",
    "label": "Spatial morphological Laplace filter",
    "version": "3.10",
    "description": "Spatial morphological Laplace filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalLaplace",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalLaplace",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalLaplaceFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialMorphologicalWhiteTopHat",
    "label": "Spatial morphological White Top-Hat filter",
    "version": "3.10",
    "description": "Spatial morphological White Top-Hat filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalWhiteTopHat",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialMorphologicalWhiteTopHat",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialMorphologicalWhiteTophatFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialPercentile",
    "label": "Spatial Percentile filter",
    "version": "3.10",
    "description": "Spatial Percentile filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialPercentile",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialPercentile",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialPercentileFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialPrewitt",
    "label": "Spatial Prewitt filter",
    "version": "3.10",
    "description": "Spatial Prewitt filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialPrewitt",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialPrewitt",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialPrewittFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpatialSobel",
    "label": "Spatial Sobel filter",
    "version": "3.10",
    "description": "Spatial Sobel filter. See Wikipedia for general information.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpatialSobel",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpatialSobel",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpatialSobelFilter\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "SpectralConvolutionBox",
    "label": "Spectral convolution Box filter",
    "version": "3.10",
    "description": "1D Box filter. The Box filter or running mean is a smoothing filter. It is not isotropic and can produce artifacts, when applied repeatedly to the same data.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralConvolutionBox",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralConvolutionBox",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralConvolutionBoxFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpectralConvolutionGaussian",
    "label": "Spectral convolution Gaussian filter",
    "version": "3.10",
    "description": "1D Gaussian filter. The Gaussian filter is a filter with great smoothing properties. It is isotropic and does not produce artifacts.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralConvolutionGaussian",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralConvolutionGaussian",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralConvolutionGaussianFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpectralConvolutionRickerWavelet",
    "label": "Spectral convolution Ricker Wavelet filter",
    "version": "3.10",
    "description": "1D Ricker Wavelet filter kernel (sometimes known as a Mexican Hat kernel). The Ricker Wavelet, or inverted Gaussian-Laplace filter, is a bandpass filter. It smooths the data and removes slowly varying or constant structures (e.g. background). It is useful for peak or multi-scale detection.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralConvolutionRickerWavelet",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralConvolutionRickerWavelet",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralConvolutionRickerWaveletFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpectralConvolutionSavitskyGolay",
    "label": "Spectral convolution Savitsky-Golay filter",
    "version": "3.10",
    "description": "1D Savitsky-Golay filter. See wikipedia for details.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralConvolutionSavitskyGolay",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralConvolutionSavitskyGolay",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralConvolutionSavitskygolayFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "SpectralConvolutionTrapezoid",
    "label": "Spectral convolution Trapezoid filter",
    "version": "3.10",
    "description": "1D Trapezoid filter.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralConvolutionTrapezoid",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralConvolutionTrapezoid",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "kernel",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Python code. See Box2DKernel for information on different parameters.",
        "label": "kernel",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "normalize",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to normalize the kernel to have a sum of one.",
        "label": "normalize",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "interpolate",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to interpolate no data pixel. Will result in renormalization of the kernel at each position ignoring pixels with no data values.",
        "label": "interpolate",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralConvolutionTrapezoidFilter\nraster=$raster\nkernel=$kernel\nnormalize=$normalize\ninterpolate=$interpolate\noutputRaster=$outputRaster"
  },
  {
    "id": "CreateClassificationDsFromRaster",
    "label": "Create classification dataset (from categorized raster layer and feature raster)",
    "version": "3.10",
    "description": "Create a classification dataset by sampling data for pixels that match the given categories and store the result as a pickle file. If the layer is not categorized, or the band with class values is selected manually, categories are derived from sampled data itself. To be more precise: i) category values are derived from unique raster band values (after excluding no data or zero data pixel), ii) category names are set equal to the category values, and iii) category colors are picked randomly.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromRaster",
        "name": "categorizedRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "CreateClassificationDsFromRaster",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromRaster",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "categoryBand",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Band with class values. If not selected, the band defined by the renderer is used. If that is also not specified, the first band is used.",
        "label": "categoryBand",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromCategorizedRasterLayerAndFeatureRaster\ncategorizedRaster=$categorizedRaster\nfeatureRaster=$featureRaster\ncategoryBand=$categoryBand\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromLibrary",
    "label": "Create classification dataset (from categorized spectral library)",
    "version": "3.10",
    "description": "Create a classification dataset from spectral profiles that matches the given categories and store the result as a pickle file. If the spectral library is not categorized, or the field with class values is selected manually, categories are derived from target data y. To be more precise: i) category values are derived from unique attribute values (after excluding no data or zero data values), ii) category names are set equal to the category values, and iii) category colors are picked randomly.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromLibrary",
        "name": "categorizedLibrary",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromLibrary",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "categoryField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with class values used as target data y. If not selected, the field defined by the renderer is used. If that is also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "categoryField",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "field",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with spectral profiles used as feature data X. If not selected, the default field named 'profiles' is used. If that is also not available, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "field",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromCategorizedSpectralLibrary\ncategorizedLibrary=$categorizedLibrary\ncategoryField=$categoryField\nfield=$field\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromVector",
    "label": "Create classification dataset (from categorized vector layer and feature raster)",
    "version": "3.10",
    "description": "Create a classification dataset by sampling data for pixels that match the given categories and store the result as a pickle file. If the layer is not categorized, or the field with class values is selected manually, categories are derived from the sampled target data y. To be more precise: i) category values are derived from unique attribute values (after excluding no data or zero data values), ii) category names are set equal to the category values, and iii) category colors are picked randomly.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromVector",
        "name": "categorizedVector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      },
      {
        "id": null,
        "parentId": "CreateClassificationDsFromVector",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromVector",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "categoryField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with class values used as target data y. If not selected, the field defined by the renderer is used. If that is also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "categoryField",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "coverage",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 50,
        "description": "Exclude all pixel where (polygon) coverage is smaller than given threshold.",
        "label": "coverage",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "majorityVoting",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to use majority voting. Turn off to use simple nearest neighbour resampling, which is much faster, but may result in highly inaccurate class decisions.",
        "label": "majorityVoting",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromCategorizedVectorLayerAndFeatureRaster\ncategorizedVector=$categorizedVector\nfeatureRaster=$featureRaster\ncategoryField=$categoryField\ncoverage=$coverage\nmajorityVoting=$majorityVoting\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromVectorWithTable",
    "label": "Create classification dataset (from categorized vector layer with attribute table)",
    "version": "3.10",
    "description": "Create a classification dataset from attribute table rows that matches the given categories and store the result as a pickle file. If the layer is not categorized, or the field with class values is selected manually, categories are derived from the target data y. To be more precise: i) category values are derived from unique attribute values (after excluding no data or zero data values), ii) category names are set equal to the category values, and iii) category colors are picked randomly.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromVectorWithTable",
        "name": "categorizedVector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromVectorWithTable",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields with values used as feature data X.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "featureFields",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "categoryField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with class values used as target data y. If not selected, the field defined by the renderer is used. If that is also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "categoryField",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromCategorizedVectorLayerWithAttributeTable\ncategorizedVector=$categorizedVector\nfeatureFields=$featureFields\ncategoryField=$categoryField\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromJsonFile",
    "label": "Create classification dataset (from JSON file)",
    "version": "3.10",
    "description": "Create a classification dataset from a JSON file and store the result as a pickle file. Example file (classifier.pkl.json) can be found in the EnMAP-Box testdata folder).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromJsonFile",
        "name": "jsonFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "JSON"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromJsonFile",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromJsonFile\njsonFile=$jsonFile\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromPythonCode",
    "label": "Create classification dataset (from Python code)",
    "version": "3.10",
    "description": "Create a classification dataset from Python code and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromPythonCode",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "code",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from enmapboxprocessing.typing import Number, List, Category, ClassifierDump; categories: List[Category] = [Category(value=1, name='class 1', color='#ff0000'),Category(value=2, name='class 2', color='#00ff00')]; features: List[str] = ['Feature 1', 'Feature 2', 'Feature 3']; X: List[List[Number]] = [[1, 2, 3],[4, 5, 6]]; y: List[List[int]] = [[1], [2]];",
        "description": "Python code specifying the classification dataset.",
        "label": "code",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromPythonCode\ncode=$code\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromTable",
    "label": "Create classification dataset (from table with categories and feature fields)",
    "version": "3.10",
    "description": "Create a classification dataset from attribute table rows that match the given categories and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromTable",
        "name": "table",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromTable",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields used as features. Values may be given as strings, but must be castable to float.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "featureFields",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "valueField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field used as class value.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "valueField",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "nameField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field used as class name. If not specified, class values are used as class names.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "nameField",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "colorField",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field used as class color. Values may be given as hex-colors, rgb-colors or int-colors.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "colorField",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromTableWithCategoriesAndFeatureFields\ntable=$table\nfeatureFields=$featureFields\nvalueField=$valueField\nnameField=$nameField\ncolorField=$colorField\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateClassificationDsFromTextFiles",
    "label": "Create classification dataset (from text files)",
    "version": "3.10",
    "description": "Create a classification dataset from tabulated text files and store the result as a pickle file. The format matches that of the FORCE Higher Level Sampling Submodule. Example files (force_features.csv and force_labels.csv) can be found in the EnMAP-Box testdata folder).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromTextFiles",
        "name": "featureFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      },
      {
        "id": null,
        "parentId": "CreateClassificationDsFromTextFiles",
        "name": "valueFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateClassificationDsFromTextFiles",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateClassificationDatasetFromTextFiles\nfeatureFile=$featureFile\nvalueFile=$valueFile\noutputClassificationDataset=$outputClassificationDataset"
  },
  {
    "id": "CreateRegressionDsFromDsVectorWithTable",
    "label": "Create regression dataset (from continuous-valued layer with attribute table)",
    "version": "3.10",
    "description": "Create a regression dataset from attribute table rows that matches the given target variables and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsVectorWithTable",
        "name": "continuousVector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsVectorWithTable",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields with values used as feature data X.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "featureFields",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "targetFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields with values used as used as target data y. If not selected, the fields defined by the renderer are used. If those are also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "targetFields",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromContinuousvaluedLayerWithAttributeTable\ncontinuousVector=$continuousVector\nfeatureFields=$featureFields\ntargetFields=$targetFields\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromDsRaster",
    "label": "Create regression dataset (from continuous-valued raster layer and feature raster)",
    "version": "3.10",
    "description": "Create a regression dataset by sampling data for labeled pixels and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsRaster",
        "name": "continuousRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsRaster",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsRaster",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "targets",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Bands with continuous-valued variables used as targets. An empty selection defaults to all bands in native order.",
        "label": "targets",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromContinuousvaluedRasterLayerAndFeatureRaster\ncontinuousRaster=$continuousRaster\nfeatureRaster=$featureRaster\ntargets=$targets\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromDsLibrary",
    "label": "Create regression dataset (from continuous-valued spectral library)",
    "version": "3.10",
    "description": "Create a regression dataset from spectral profiles that matches the given target variables and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsLibrary",
        "name": "continuousLibrary",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsLibrary",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "targetFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields with continuous-valued values used as target data y. If not selected, the fields defined by the renderer is used. If those are also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "targetFields",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "field",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with spectral profiles used as feature data X. If not selected, the default field named 'profiles' is used. If that is also not available, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "field",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromContinuousvaluedSpectralLibrary\ncontinuousLibrary=$continuousLibrary\ntargetFields=$targetFields\nfield=$field\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromDsVector",
    "label": "Create regression dataset (from continuous-valued vector layer and feature raster)",
    "version": "3.10",
    "description": "Create a regression dataset by sampling data and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsVector",
        "name": "continuousVector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      },
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsVector",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromDsVector",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "targetFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields used as target data y. If not selected, the fields defined by the renderer are used. If those are also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "targetFields",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromContinuousvaluedVectorLayerAndFeatureRaster\ncontinuousVector=$continuousVector\nfeatureRaster=$featureRaster\ntargetFields=$targetFields\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromJsonFile",
    "label": "Create regression dataset (from JSON file)",
    "version": "3.10",
    "description": "Create a regression dataset from a JSON file and store the result as a pickle file. Example file (regressor.pkl.json) can be found in the EnMAP-Box testdata folder).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromJsonFile",
        "name": "jsonFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "JSON"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromJsonFile",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromJsonFile\njsonFile=$jsonFile\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromPythonCode",
    "label": "Create regression dataset (from Python code)",
    "version": "3.10",
    "description": "Create a regression dataset from Python code and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromPythonCode",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "code",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from enmapboxprocessing.typing import Number, List, Target, RegressorDump; targets: List[Target] = [Target(name='variable 1', color='#ff0000'), Target(name='variable 2', color='#00ff00')]; features: List[str] = ['Feature 1', 'Feature 2', 'Feature 3']; X: List[List[Number]] = [[1, 2, 3], [4, 5, 6]]; y: List[List[float]] = [[1.1, 1.2], [2.1, 2.2]]",
        "description": "Python code specifying the regression dataset.",
        "label": "code",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromPythonCode\ncode=$code\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromTable",
    "label": "Create regression dataset (from table with target and feature fields)",
    "version": "3.10",
    "description": "Create a regression dataset from attribute table rows and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromTable",
        "name": "table",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromTable",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields used as features. Values may be given as strings, but must be castable to float.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "featureFields",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "targetFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields used as targets. Values may be given as strings, but must be castable to float.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "targetFields",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromTableWithTargetAndFeatureFields\ntable=$table\nfeatureFields=$featureFields\ntargetFields=$targetFields\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromTextFiles",
    "label": "Create regression dataset (from text files)",
    "version": "3.10",
    "description": "Create a regression dataset from tabulated text files and store the result as a pickle file. The format matches that of the FORCE Higher Level Sampling Submodule. Example files (force_features.csv and force_labels.csv) can be found in the EnMAP-Box testdata folder).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromTextFiles",
        "name": "featureFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      },
      {
        "id": null,
        "parentId": "CreateRegressionDsFromTextFiles",
        "name": "valueFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromTextFiles",
        "name": "outputRegressionDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetFromTextFiles\nfeatureFile=$featureFile\nvalueFile=$valueFile\noutputRegressionDataset=$outputRegressionDataset"
  },
  {
    "id": "CreateRegressionDsFromClassificationDs",
    "label": "Create regression dataset (SynthMix from classification dataset)",
    "version": "3.10",
    "description": "Create synthetically mixed regression datasets, one for each category. Results are stored as <category.name>.pkl files inside the destination folder.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromClassificationDs",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRegressionDsFromClassificationDs",
        "name": "outputFolder",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "output/"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Number of mixtures per class",
        "label": "n",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "background",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": 0,
        "description": "Proportion of background mixtures.",
        "label": "background",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "includeEndmember",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to include the original library spectra into the dataset.",
        "label": "includeEndmember",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "mixingProbabilities",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": " 0.5, 0.5",
        "description": "A list of probabilities for using 2, 3, 4, ... endmember mixing models. Trailing 0 probabilities can be skipped. The default values of 0.5, 0.5,results in 50% 2-endmember and 50% 3-endmember models.",
        "label": "mixingProbabilities",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "allowWithinClassMixtures",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to allow mixtures with profiles belonging to the same class.",
        "label": "allowWithinClassMixtures",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "classProbabilities",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A list of probabilities for drawing profiles from each class. If not specified, class probabilities are proportional to the class size.",
        "label": "classProbabilities",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRegressionDatasetSynthmixFromClassificationDataset\ndataset=$dataset\nn=$n\nbackground=$background\nincludeEndmember=$includeEndmember\nmixingProbabilities=$mixingProbabilities\nallowWithinClassMixtures=$allowWithinClassMixtures\nclassProbabilities=$classProbabilities\noutputFolder=$outputFolder"
  },
  {
    "id": "CreateUnsupervisedDsFromFeatureRaster",
    "label": "Create unsupervised dataset (from feature raster)",
    "version": "3.10",
    "description": "Create an unsupervised dataset by sampling data from valid pixels and store the result as a pickle file. A pixel is concidered valid, if the pixel profile is free of no data values, and not excluded by the (optionally) selected mask layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromFeatureRaster",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromFeatureRaster",
        "name": "mask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromFeatureRaster",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromFeatureRaster\nfeatureRaster=$featureRaster\nmask=$mask\nsampleSize=$sampleSize\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "CreateUnsupervisedDsFromJsonFile",
    "label": "Create unsupervised dataset (from JSON file)",
    "version": "3.10",
    "description": "Create a unsupervised dataset from a JSON file and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromJsonFile",
        "name": "jsonFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "JSON"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromJsonFile",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromJsonFile\njsonFile=$jsonFile\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "CreateUnsupervisedDsFromPythonCode",
    "label": "Create unsupervised dataset (from Python code)",
    "version": "3.10",
    "description": "Create an unsupervised dataset from Python code and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromPythonCode",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "code",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from enmapboxprocessing.typing import Number, List; features: List[str] = ['Feature 1', 'Feature 2', 'Feature 3']; X: List[List[Number]] = [[1, 2, 3], [4, 5, 6]]",
        "description": "Python code specifying the unsupervised dataset.",
        "label": "code",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromPythonCode\ncode=$code\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "CreateUnsupervisedDsFromSpectralLibrary",
    "label": "Create unsupervised dataset (from spectral library)",
    "version": "3.10",
    "description": "Create an unsupervised dataset from spectral profiles and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromSpectralLibrary",
        "name": "library",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromSpectralLibrary",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "field",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with spectral profiles used as feature data X. If not selected, the default field named 'profiles' is used. If that is also not available, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "field",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromSpectralLibrary\nlibrary=$library\nfield=$field\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "CreateUnsupervisedDsFromTextFile",
    "label": "Create unsupervised dataset (from text file)",
    "version": "3.10",
    "description": "Create an unsupervised dataset from a tabulated text file and store the result as a pickle file. The format matches that of the FORCE Higher Level Sampling Submodule. An example file (force_features.csv) can be found in the EnMAP-Box testdata folder).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromTextFile",
        "name": "featureFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromTextFile",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromTextFile\nfeatureFile=$featureFile\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "CreateUnsupervisedDsFromVectorWithTable",
    "label": "Create unsupervised dataset (from vector layer with attribute table)",
    "version": "3.10",
    "description": "Create an unsupervised dataset from attribute table and store the result as a pickle file.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromVectorWithTable",
        "name": "vector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateUnsupervisedDsFromVectorWithTable",
        "name": "outputUnsupervisedDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureFields",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Fields with values used as feature data X.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "featureFields",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateUnsupervisedDatasetFromVectorLayerWithAttributeTable\nvector=$vector\nfeatureFields=$featureFields\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "MergeClassificationDatasets",
    "label": "Merge classification datasets",
    "version": "3.10",
    "description": "Merges a list of classification datasets.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "MergeClassificationDatasets",
        "name": "dataset1",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "MergeClassificationDatasets",
        "name": "dataset2",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "MergeClassificationDatasets",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:MergeClassificationDatasets\ndatasets=$datasets\noutputUnsupervisedDataset=$outputUnsupervisedDataset"
  },
  {
    "id": "RandomSamplesFromClassificationDataset",
    "label": "Random samples from classification dataset",
    "version": "3.10",
    "description": "Split a dataset by randomly drawing samples.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RandomSamplesFromClassificationDataset",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RandomSamplesFromClassificationDataset",
        "name": "outputDatasetRandomSample",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "sample_output.pkl"
        }
      },
      {
        "id": null,
        "parentId": "RandomSamplesFromClassificationDataset",
        "name": "outputDatasetRandomSampleComplement",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "complement_output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Number of samples to draw from each category. Set a single value N to draw N samples for each category. Set a list of values N1, N2, ... Ni, ... to draw Ni samples for category i.",
        "label": "n",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "replace",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to draw samples with replacement.",
        "label": "replace",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "proportional",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to interprete number of samples N or Ni as percentage to be drawn from each category.",
        "label": "proportional",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "seed",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "The seed for the random generator can be provided.",
        "label": "seed",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RandomSamplesFromClassificationDataset\ndataset=$dataset\nn=$n\nreplace=$replace\nproportional=$proportional\nseed=$seed\noutputDatasetRandomSample=$outputDatasetRandomSample\noutputDatasetRandomSampleComplement=$outputDatasetRandomSampleComplement"
  },
  {
    "id": "RandomSamplesFromRegressionDataset",
    "label": "Random samples from regression dataset",
    "version": "3.10",
    "description": "Split a dataset by randomly drawing samples.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RandomSamplesFromRegressionDataset",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RandomSamplesFromRegressionDataset",
        "name": "outputDatasetRandomSample",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "sample_output.pkl"
        }
      },
      {
        "id": null,
        "parentId": "RandomSamplesFromRegressionDataset",
        "name": "outputDatasetRandomSampleComplement",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "complement_output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "bins",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1,
        "description": "Number of bins used to stratify the target range.",
        "label": "bins",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Number of samples to draw from each category. Set a single value N to draw N samples for each category. Set a list of values N1, N2, ... Ni, ... to draw Ni samples for category i.",
        "label": "n",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "replace",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to draw samples with replacement.",
        "label": "replace",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "proportional",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to interprete number of samples N or Ni as percentage to be drawn from each category.",
        "label": "proportional",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "seed",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "The seed for the random generator can be provided.",
        "label": "seed",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RandomSamplesFromRegressionDataset\ndataset=$dataset\nbins=$bins\nn=$n\nreplace=$replace\nproportional=$proportional\nseed=$seed\noutputDatasetRandomSample=$outputDatasetRandomSample\noutputDatasetRandomSampleComplement=$outputDatasetRandomSampleComplement"
  },
  {
    "id": "SelectFeaturesFromDataset",
    "label": "Select features from dataset",
    "version": "3.10",
    "description": "Subset and/or reorder features in feature data X.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SelectFeaturesFromDataset",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SelectFeaturesFromDataset",
        "name": "outputDatasetFeatureSubset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "featureList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Comma separated list of feature names or positions. E.g. use <code>1, ‘Feature 2’, 3</code> to select the first three features.",
        "label": "featureList",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SelectFeaturesFromDataset\ndataset=$dataset\nfeatureList=$featureList\noutputDatasetFeatureSubset=$outputDatasetFeatureSubset"
  },
  {
    "id": "SaveSpectralLibraryAsGeoJSONFile",
    "label": "Save spectral library as GeoJSON file",
    "version": "3.10",
    "description": "Save a spectral library as a human-readable GeoJSON text file. All binary profile fields will be converted into human-readable dictionary strings.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SaveSpectralLibraryAsGeoJSONFile",
        "name": "library",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "JSON"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SaveSpectralLibraryAsGeoJSONFile",
        "name": "outputFile",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.geojson"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:SaveSpectralLibraryAsGeojsonFile\nlibrary=$library\noutputFile=$outputFile"
  },
  {
    "id": "ClassifierFeatureRanking",
    "label": "Classifier feature ranking (permutation importance)",
    "version": "3.10",
    "description": "Permutation feature importance is a model inspection technique that is especially useful for non-linear or opaque estimators. The permutation feature importance is defined to be the decrease in a model score when a single feature value is randomly shuffled. This procedure breaks the relationship between the feature and the target, thus the drop in the model score is indicative of how much the model depends on the feature. This technique benefits from being model agnostic and can be calculated many times with different permutations of the feature.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ClassifierFeatureRanking",
        "name": "classifier",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "ClassifierFeatureRanking",
        "name": "trainDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "ClassifierFeatureRanking",
        "name": "testDataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ClassifierFeatureRanking",
        "name": "outputPermutationImportanceRanking",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "evaluationMetric",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "7",
        "description": "An evaluation metric to use. See Metrics and scoring: quantifying the quality of predictions for further information.<br/>Available values:<br/> - 0: accuracy<br/> - 1: balanced_accuracy<br/> - 2: top_k_accuracy<br/> - 3: average_precision<br/> - 4: neg_brier_score<br/> - 5: f1<br/> - 6: f1_micro<br/> - 7: f1_macro<br/> - 8: f1_weighted<br/> - 9: f1_samples<br/> - 10: neg_log_loss<br/> - 11: precision<br/> - 12: recall<br/> - 13: jaccard<br/> - 14: roc_auc<br/> - 15: roc_auc_ovr<br/> - 16: roc_auc_ovo<br/> - 17: roc_auc_ovr_weighted<br/> - 18: roc_auc_ovo_weighted<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "evaluationMetric",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "repeats",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 10,
        "description": "Number of times to permute a feature.",
        "label": "repeats",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "seed",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "The seed for the random generator can be provided.",
        "label": "seed",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ClassifierFeatureRankingPermutationImportance\nclassifier=$classifier\ntrainDataset=$trainDataset\ntestDataset=$testDataset\nevaluationMetric=$evaluationMetric\nrepeats=$repeats\nseed=$seed\nopenReport=false\noutputPermutationImportanceRanking=$outputPermutationImportanceRanking"
  },
  {
    "id": "HierarchicalFeatureClustering",
    "label": "Hierarchical feature clustering",
    "version": "3.10",
    "description": "Evaluate feature multicollinearity by performing hierarchical/agglomerative clustering with Ward linkage using squared Spearman rank-order correlation as distance between features. The result report includes i) pairwise squared Spearman rank-order correlation matrix, ii) clustering dendrogram, iii) inter-cluster correlation distribution, iv) intra-cluster correlation distribution, and v) a clustering hierarchy table detailing selected cluster representatives for each cluster size n. For further analysis, all relevant results are also stored as a JSON sidecar file next to the report.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "HierarchicalFeatureClustering",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "HierarchicalFeatureClustering",
        "name": "outputHierarchicalFeatureClustering",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "noPlot",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Skip the creation of plots, which can take a lot of time for large features sets.",
        "label": "noPlot",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:HierarchicalFeatureClustering\ndataset=$dataset\nnoPlot=$noPlot\nopenReport=false\noutputHierarchicalFeatureClustering=$outputHierarchicalFeatureClustering"
  },
  {
    "id": "ImportDesisL1BProduct",
    "label": "Import DESIS L1B product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength and FWHM information is set and data is scaled according to data gain/offset values.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportDesisL1BProduct",
        "name": "outputDesisL1CRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportDesisL1BProduct\nfile=$file\noutputDesisL1CRaster=$outputDesisL1CRaster"
  },
  {
    "id": "ImportDesisL1CProduct",
    "label": "Import DESIS L1C product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength and FWHM information is set and data is scaled according to data gain/offset values. Note that the DESIS L1C spectral data file is band interleaved by pixel and compressed, which is very disadvantageous for visualization in QGIS / EnMAP-Box. For faster exploration concider saving the resulting VRT raster layer as GTiff format via the 'Translate raster layer' algorithm.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportDesisL1CProduct",
        "name": "outputDesisL1CRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportDesisL1CProduct\nfile=$file\noutputDesisL1CRaster=$outputDesisL1CRaster"
  },
  {
    "id": "ImportDesisL2AProduct",
    "label": "Import DESIS L2A product",
    "version": "3.10",
    "description": "The metadata XML file associated with the product. Instead of executing this algorithm, you may drag&drop the metadata XML file directly from your system file browser onto the EnMAP-Box map view area.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportDesisL2AProduct",
        "name": "outputDesisL2ARaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportDesisL2AProduct\nfile=$file\noutputDesisL2ARaster=$outputDesisL2ARaster"
  },
  {
    "id": "ImportEnmapL1BProduct",
    "label": "Import EnMAP L1B product",
    "version": "3.10",
    "description": "Prepare VNIR and SWIR spectral raster layer from the given product. Wavelength and FWHM information is set and data is scaled according to data gain/offset values.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportEnmapL1BProduct",
        "name": "outputEnmapL1BRasterVnir",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportEnmapL1BProduct",
        "name": "outputEnmapL1BRasterSwir",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportEnmapL1BProduct\nfile=$file\noutputEnmapL1BRasterVnir=$outputEnmapL1BRasterVnir\noutputEnmapL1BRasterSwir=$outputEnmapL1BRasterSwir"
  },
  {
    "id": "ImportEnmapL1CProduct",
    "label": "Import EnMAP L1C product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength and FWHM information is set and data is scaled according to data gain/offset values.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportEnmapL1CProduct",
        "name": "outputEnmapL1CRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportEnmapL1CProduct\nfile=$file\noutputEnmapL1CRaster=$outputEnmapL1CRaster"
  },
  {
    "id": "ImportEnmapL2AProduct",
    "label": "Import EnMAP L2A product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength and FWHM information is set and data is scaled into the 0 to 10000 range.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportEnmapL2AProduct",
        "name": "outputEnmapL2ARaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportEnmapL2AProduct\nfile=$file\noutputEnmapL2ARaster=$outputEnmapL2ARaster"
  },
  {
    "id": "ImportLandsatL2Product",
    "label": "Import Landsat L2 product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength information is set and data is scaled into the 0 to 1 range.Supports Landsat 4 to 9, collection 1 and 2.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportLandsatL2Product",
        "name": "outputLandsatL2Raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportLandsatL2Product\nfile=$file\noutputEnmapL2ARaster=$outputEnmapL2ARaster"
  },
  {
    "id": "ImportPrismaL1Product",
    "label": "Import PRISMA L1 product",
    "version": "3.10",
    "description": "Import PRISMA L1 product from HE5 file to QGIS/GDAL conform GTiff/VRT file format.Note that for the spectral cube and error matrix, the interleave is transposed and stored as GTiff to enable proper visualization in QGIS.All other sub-datasets are stored as light-weight VRT files. For further details visit the PRISMA Documentation Area.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_spectralCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_panCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_cloudMask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output2.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_landCoverMask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output3.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_sunGlintMask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output4.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrisma1_spectralErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output5.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_spectralGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output6.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_panGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output7.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL1Product",
        "name": "outputPrismaL1_panErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output8.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "spectralRegion",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "Spectral region to be imported.<br/>Available values:<br/> - 0: VNIR/SWIR combined<br/> - 1: VNIR only<br/> - 2: SWIR only<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "spectralRegion",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportPrismaL1Product\nfile=$file\nspectralRegion=$spectralRegion\noutputPrismaL1_spectralCube=$outputPrismaL1_spectralCube\noutputPrismaL1_panCube=$outputPrismaL1_panCube\noutputPrismaL1_cloudMask=$outputPrismaL1_cloudMask\noutputPrismaL1_landCoverMask=$outputPrismaL1_landCoverMask\noutputPrismaL1_sunGlintMask=$outputPrismaL1_sunGlintMask\noutputPrisma1_spectralErrorMatrix=$outputPrisma1_spectralErrorMatrix\noutputPrismaL1_spectralGeolocationFields=$outputPrismaL1_spectralGeolocationFields\noutputPrismaL1_panGeolocationFields=$outputPrismaL1_panGeolocationFields\noutputPrismaL1_panErrorMatrix=$outputPrismaL1_panErrorMatrix"
  },
  {
    "id": "ImportPrismaL2BProduct",
    "label": "Import PRISMA L2B product",
    "version": "3.10",
    "description": "Import PRISMA L2B product from HE5 file to QGIS/GDAL conform GTiff/VRT file format.Note that for the spectral cube and error matrix, the interleave is transposed and stored as GTiff to enable proper visualization in QGIS.All other sub-datasets are stored as light-weight VRT files. For further details visit the PRISMA Documentation Area.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_spectralCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_panCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrisma2B_spectralErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output2.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_spectralGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output3.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_spectralGeometricFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output4.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_panGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output5.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2BProduct",
        "name": "outputPrismaL2B_panErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output6.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "spectralRegion",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "Spectral region to be imported.<br/>Available values:<br/> - 0: VNIR/SWIR combined<br/> - 1: VNIR only<br/> - 2: SWIR only<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "spectralRegion",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportPrismaL2BProduct\nfile=$file\nspectralRegion=$spectralRegion\noutputPrismaL2B_spectralCube=$outputPrismaL2B_spectralCube\noutputPrismaL2B_panCube=$outputPrismaL2B_panCube\noutputPrisma2B_spectralErrorMatrix=$outputPrisma2B_spectralErrorMatrix\noutputPrismaL2B_spectralGeolocationFields=$outputPrismaL2B_spectralGeolocationFields\noutputPrismaL2B_spectralGeometricFields=$outputPrismaL2B_spectralGeometricFields\noutputPrismaL2B_panGeolocationFields=$outputPrismaL2B_panGeolocationFields\noutputPrismaL2B_panErrorMatrix=$outputPrismaL2B_panErrorMatrix"
  },
  {
    "id": "ImportPrismaL2CProduct",
    "label": "Import PRISMA L2C product",
    "version": "3.10",
    "description": "Import PRISMA L2C product from HE5 file to QGIS/GDAL conform GTiff/VRT file format.Note that for the spectral cube and error matrix, the interleave is transposed and stored as GTiff to enable proper visualization in QGIS.All other sub-datasets are stored as light-weight VRT files. For further details visit the PRISMA Documentation Area.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_spectralCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_panCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrisma2C_spectralErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output2.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_spectralGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output3.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_spectralGeometricFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output4.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_panGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output5.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2CProduct",
        "name": "outputPrismaL2C_panErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output6.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "spectralRegion",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "Spectral region to be imported.<br/>Available values:<br/> - 0: VNIR/SWIR combined<br/> - 1: VNIR only<br/> - 2: SWIR only<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "spectralRegion",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportPrismaL2CProduct\nfile=$file\nspectralRegion=$spectralRegion\noutputPrismaL2C_spectralCube=$outputPrismaL2C_spectralCube\noutputPrismaL2C_panCube=$outputPrismaL2C_panCube\noutputPrisma2C_spectralErrorMatrix=$outputPrisma2C_spectralErrorMatrix\noutputPrismaL2C_spectralGeolocationFields=$outputPrismaL2C_spectralGeolocationFields\noutputPrismaL2C_spectralGeometricFields=$outputPrismaL2C_spectralGeometricFields\noutputPrismaL2C_panGeolocationFields=$outputPrismaL2C_panGeolocationFields\noutputPrismaL2C_panErrorMatrix=$outputPrismaL2C_panErrorMatrix"
  },
  {
    "id": "ImportPrismaL2DProduct",
    "label": "Import PRISMA L2D product",
    "version": "3.10",
    "description": "Import PRISMA L2D product from HE5 file to QGIS/GDAL conform GTiff/VRT file format with proper coordinate reference system.Note that for the spectral cube and error matrix, the interleave is transposed and stored as GTiff to enable proper visualization in QGIS.All other sub-datasets are stored as light-weight VRT files. For further details visit the PRISMA Documentation Area.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_spectralCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_panCube",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_spectralGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output2.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_spectralGeometricFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output3.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_spectralErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output4.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_panGeolocationFields",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output5.vrt"
        }
      },
      {
        "id": null,
        "parentId": "ImportPrismaL2DProduct",
        "name": "outputPrismaL2D_panErrorMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output6.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "spectralRegion",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "Spectral region to be imported.<br/>Available values:<br/> - 0: VNIR/SWIR combined<br/> - 1: VNIR only<br/> - 2: SWIR only<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "spectralRegion",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "badBandThreshold",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "If the proportion of erroneous pixels in the VNIR/SWIR Pixel Error Matrix,exceeds the bad band threshold (a value between 0 and 1), the band is marked as a bad band. If specified, Output VNIR/SWIR Error Matrix raster layer needs to be specified as well.",
        "label": "badBandThreshold",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "badPixelType",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "Pixels concidered to be erroneous.<br/>Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'<br/>Available values:<br/> - 0: Invalid pixel from L1 product<br/> - 1: Negative value after atmospheric correction<br/> - 2: Saturated value after atmospheric correction<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "badPixelType",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportPrismaL2DProduct\nfile=$file\nspectralRegion=$spectralRegion\nbadBandThreshold=$badBandThreshold\nbadPixelType=$badPixelType\noutputPrismaL2D_spectralCube=$outputPrismaL2D_spectralCube\noutputPrismaL2D_panCube=$outputPrismaL2D_panCube\noutputPrismaL2D_spectralGeolocationFields=$outputPrismaL2D_spectralGeolocationFields\noutputPrismaL2D_spectralGeometricFields=$outputPrismaL2D_spectralGeometricFields\noutputPrismaL2D_spectralErrorMatrix=$outputPrismaL2D_spectralErrorMatrix\noutputPrismaL2D_panGeolocationFields=$outputPrismaL2D_panGeolocationFields\noutputPrismaL2D_panErrorMatrix=$outputPrismaL2D_panErrorMatrix"
  },
  {
    "id": "ImportSentinel2L2AProduct",
    "label": "Import Sentinel-2 L2A product",
    "version": "3.10",
    "description": "Prepare a spectral raster layer from the given product. Wavelength information is set and data is scaled into the 0 to 10000 range.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [],
    "targets": [
      {
        "id": null,
        "parentId": "ImportSentinel2L2AProduct",
        "name": "outputSentinel2L2ARaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "file",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The metadata XML file associated with the product.",
        "label": "Metadata file",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "bandList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0,1,2,3,4,5,6,7,8,9,10,11",
        "description": "Bands to be stacked together. Defaults to all 10m and 20m bands ordered by center wavelength. Note that the destination pixel size matches the smallest/finest pixel size over all selected bands.<br/>Available values:<br/> - 0: B1, Coastal aerosol (443 Nanometers)[60 Meter]<br/> - 1: B2, Blue (492 Nanometers)[10 Meter]<br/> - 2: B3, Green (560 Nanometers)[10 Meter]<br/> - 3: B4, Red (665 Nanometers)[10 Meter]<br/> - 4: B5, Vegetation red edge (704 Nanometers)[20 Meter]<br/> - 5: B6, Vegetation red edge (741 Nanometers)[20 Meter]<br/> - 6: B7, Vegetation red edge (783 Nanometers)[20 Meter]<br/> - 7: B8, NIR (833 Nanometers)[10 Meter]<br/> - 8: B8A, Narrow NIR (865 Nanometers)[20 Meter]<br/> - 9: B9, Water vapour (945 Nanometers)[60 Meter]<br/> - 10: B11, SWIR (1614 Nanometers)[20 Meter]<br/> - 11: B12, SWIR (2202 Nanometers)[20 Meter]<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "bandList",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ImportSentinel2L2AProduct\nfile=$file\nbandList=$bandList\noutputSentinel2L2ARaster=$outputSentinel2L2ARaster"
  },
  {
    "id": "ApplyMaskLayerToRasterLayer",
    "label": "Apply mask layer to raster layer",
    "version": "3.10",
    "description": "Areas where the mask layer evaluates to false are set to the source no data value (0, if undefined).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ApplyMaskLayerToRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "ApplyMaskLayerToRasterLayer",
        "name": "mask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ApplyMaskLayerToRasterLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:ApplyMaskLayerToRasterLayer\nraster=$raster\nmask=$mask\noutputRaster=$outputRaster"
  },
  {
    "id": "CreateMaskRaster",
    "label": "Create mask raster layer",
    "version": "3.10",
    "description": "Create a mask raster layer by applying a user-defined evaluation function band-wise to a source raster layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateMaskRaster",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateMaskRaster",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "import numpy as np;ndv=lambda noDataValue: 0 if noDataValue is None else noDataValue; exec('def function(array: np.ndarray, noDataValue: float): noDataValue=ndv(noDataValue); marray = np.not_equal(array, noDataValue); marray[np.logical_not(np.isfinite(array))] = 0; return marray')",
        "description": "Python code defining the evaluation function. The defined function must return a binary-valued array with same shape as the input array.",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateMaskRasterLayer\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "LayerToMaskRasterLayer",
    "label": "Layer to mask raster layer",
    "version": "3.10",
    "description": "",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "LayerToMaskRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "LayerToMaskRasterLayer",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "LayerToMaskRasterLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:LayerToMaskRasterLayer\nraster=$raster\ngrid=$grid\noutputMask=$outputMask"
  },
  {
    "id": "AggregateRasterLayerBands",
    "label": "Aggregate raster layer bands",
    "version": "3.10",
    "description": "Compute various aggregation functions over all bands, while ignoring no data values.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "AggregateRasterLayerBands",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "AggregateRasterLayerBands",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "function",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Functions to be used. Number and order of selected functions equals number and order of output bands.<br/>Available values:<br/> - 0: arithmetic mean<br/> - 1: standard deviation<br/> - 2: variance<br/> - 3: minimum<br/> - 4: median<br/> - 5: maximum<br/> - 6: sum<br/> - 7: product<br/> - 8: range<br/> - 9: interquartile range<br/> - 10: any true<br/> - 11: all true<br/> - 12: arg minimum<br/> - 13: arg maximum<br/> - 14: 0-th percentile<br/> - 15: 1-th percentile<br/> - 16: 2-th percentile<br/> - 17: 3-th percentile<br/> - 18: 4-th percentile<br/> - 19: 5-th percentile<br/> - 20: 6-th percentile<br/> - 21: 7-th percentile<br/> - 22: 8-th percentile<br/> - 23: 9-th percentile<br/> - 24: 10-th percentile<br/> - 25: 11-th percentile<br/> - 26: 12-th percentile<br/> - 27: 13-th percentile<br/> - 28: 14-th percentile<br/> - 29: 15-th percentile<br/> - 30: 16-th percentile<br/> - 31: 17-th percentile<br/> - 32: 18-th percentile<br/> - 33: 19-th percentile<br/> - 34: 20-th percentile<br/> - 35: 21-th percentile<br/> - 36: 22-th percentile<br/> - 37: 23-th percentile<br/> - 38: 24-th percentile<br/> - 39: 25-th percentile<br/> - 40: 26-th percentile<br/> - 41: 27-th percentile<br/> - 42: 28-th percentile<br/> - 43: 29-th percentile<br/> - 44: 30-th percentile<br/> - 45: 31-th percentile<br/> - 46: 32-th percentile<br/> - 47: 33-th percentile<br/> - 48: 34-th percentile<br/> - 49: 35-th percentile<br/> - 50: 36-th percentile<br/> - 51: 37-th percentile<br/> - 52: 38-th percentile<br/> - 53: 39-th percentile<br/> - 54: 40-th percentile<br/> - 55: 41-th percentile<br/> - 56: 42-th percentile<br/> - 57: 43-th percentile<br/> - 58: 44-th percentile<br/> - 59: 45-th percentile<br/> - 60: 46-th percentile<br/> - 61: 47-th percentile<br/> - 62: 48-th percentile<br/> - 63: 49-th percentile<br/> - 64: 50-th percentile<br/> - 65: 51-th percentile<br/> - 66: 52-th percentile<br/> - 67: 53-th percentile<br/> - 68: 54-th percentile<br/> - 69: 55-th percentile<br/> - 70: 56-th percentile<br/> - 71: 57-th percentile<br/> - 72: 58-th percentile<br/> - 73: 59-th percentile<br/> - 74: 60-th percentile<br/> - 75: 61-th percentile<br/> - 76: 62-th percentile<br/> - 77: 63-th percentile<br/> - 78: 64-th percentile<br/> - 79: 65-th percentile<br/> - 80: 66-th percentile<br/> - 81: 67-th percentile<br/> - 82: 68-th percentile<br/> - 83: 69-th percentile<br/> - 84: 70-th percentile<br/> - 85: 71-th percentile<br/> - 86: 72-th percentile<br/> - 87: 73-th percentile<br/> - 88: 74-th percentile<br/> - 89: 75-th percentile<br/> - 90: 76-th percentile<br/> - 91: 77-th percentile<br/> - 92: 78-th percentile<br/> - 93: 79-th percentile<br/> - 94: 80-th percentile<br/> - 95: 81-th percentile<br/> - 96: 82-th percentile<br/> - 97: 83-th percentile<br/> - 98: 84-th percentile<br/> - 99: 85-th percentile<br/> - 100: 86-th percentile<br/> - 101: 87-th percentile<br/> - 102: 88-th percentile<br/> - 103: 89-th percentile<br/> - 104: 90-th percentile<br/> - 105: 91-th percentile<br/> - 106: 92-th percentile<br/> - 107: 93-th percentile<br/> - 108: 94-th percentile<br/> - 109: 95-th percentile<br/> - 110: 96-th percentile<br/> - 111: 97-th percentile<br/> - 112: 98-th percentile<br/> - 113: 99-th percentile<br/> - 114: 100-th percentile<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "function",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:AggregateRasterLayerBands\nraster=$raster\nfunction=$function\noutputRaster=$outputRaster"
  },
  {
    "id": "ConvexHull",
    "label": "Convex hull and continuum-removal",
    "version": "3.10",
    "description": "Calculate convex hull and continuum-removed raster layers.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ConvexHull",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ConvexHull",
        "name": "outputConvexHull",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      },
      {
        "id": null,
        "parentId": "ConvexHull",
        "name": "outputContinuumRemoved",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output1.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "xUnits",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0",
        "description": "The x units used for convex hull calculations. In case of Nanometers, only spectral bands are used.<br/>Available values:<br/> - 0: Band numbers<br/> - 1: Nanometers<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "xUnits",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:ConvexHullAndContinuumremoval\nraster=$raster\nxUnits=$xUnits\noutputConvexHull=$outputConvexHull\noutputContinuumRemoved=$outputContinuumRemoved"
  },
  {
    "id": "CreateSpectralIndices",
    "label": "Create spectral indices",
    "version": "3.10",
    "description": "Create a stack of Awesome Spectral Indices and/or custom indices. Credits: the Awesome Spectral Indices project provides a ready-to-use curated list of Spectral Indices for Remote Sensing applications, maintained by David Montero Loaiza. Note that the list of available indices was last updated on 2021-11-15. Should you need other indices added after this date, please file an issue.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateSpectralIndices",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateSpectralIndices",
        "name": "outputVrt",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "indices",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "NDVI",
        "description": "The list of indices to be created. Usage examples: Create (predefined) NDVI: <code>NDVI</code> Create stack of NDVI and EVI: <code>NDVI, EVI</code> Create custom index: <code>MyNDVI = (N - R) / (N + R)</code> See the full list of predefined Awesome Spectral Indices.",
        "label": "indices",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "scale",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Spectral reflectance scale factor. Some indices require data to be scaled into the 0 to 1 range. If your data is scaled differently, specify an appropriate scale factor.E.g. for Int16 data scaled into the 0 to 10000 range, use a value of 10000.",
        "label": "scale",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "A",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Aerosols band",
        "label": "A",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "B",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Blue band",
        "label": "B",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "G",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Green band",
        "label": "G",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Red band",
        "label": "R",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "RE1",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Red Edge 1 band",
        "label": "RE1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "RE2",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Red Edge 2 band",
        "label": "RE2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "RE3",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Red Edge 3 band",
        "label": "RE3",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "RE4",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Red Edge 4 band",
        "label": "RE4",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "N",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "NIR band",
        "label": "N",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "S1",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "SWIR 1 band",
        "label": "S1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "S2",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "SWIR 2 band",
        "label": "S2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "T1",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Thermal 1 band",
        "label": "T1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "T2",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Thermal 2 band",
        "label": "T2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "L",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": -1,
        "description": "Canopy background adjustment",
        "label": "L",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "g",
        "type": "REGULAR",
        "dataType": "double",
        "defaultValue": 2.5,
        "description": "Gain factor",
        "label": "g",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "C1",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 6,
        "description": "Coefficient 1 for the aerosol resistance term",
        "label": "C1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "C2",
        "type": "REGULAR",
        "dataType": "double",
        "defaultValue": 7.5,
        "description": "Coefficient 2 for the aerosol resistance term",
        "label": "C2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "cexp",
        "type": "REGULAR",
        "dataType": "double",
        "defaultValue": 1.16,
        "description": "Exponent used for OCVI",
        "label": "cexp",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "nexp",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 2,
        "description": "Exponent used for GDVI",
        "label": "nexp",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "alpha",
        "type": "REGULAR",
        "dataType": "double",
        "defaultValue": 0.1,
        "description": "Weighting coefficient used for WDRVI",
        "label": "alpha",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "gamma",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1,
        "description": "Weighting coefficient used for ARVI",
        "label": "gamma",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "sla",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1,
        "description": "Soil line slope",
        "label": "sla",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "slb",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Soil line intercept",
        "label": "slb",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateSpectralIndices\nraster=$raster\nindices=$indices\nA=$A\nB=$B\nG=$G\nR=$R\nRE1=$RE1\nRE2=$RE2\nRE3=$RE3\nRE4=$RE4\nN=$N\nscale=$scale\nS1=$S1\nS2=$S2\nT1=$T1\nT2=$T2\nL=$L\ng=$g\nC1=$C1\nC2=$C2\ncexp=$cexp\nnexp=$nexp\nalpha=$alpha\ngamma=$gamma\nsla=$sla\nslb=$slb\noutputtif=$outputtif"
  },
  {
    "id": "RasterLayerZonalAggregation",
    "label": "Raster layer zonal aggregation",
    "version": "3.10",
    "description": "double",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RasterLayerZonalAggregation",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RasterLayerZonalAggregation",
        "name": "categorizedRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RasterLayerZonalAggregation",
        "name": "outputTable",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "output.csv"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:RasterLayerZonalAggregation\nraster=$raster\ncategorizedRaster=$categorizedRaster\noutputTable=$outputTable"
  },
  {
    "id": "rasterMath",
    "label": "Raster math",
    "version": "3.10",
    "description": "Perform mathematical calculations on raster layer and vector layer data. Use any NumPy-based arithmetic, or even arbitrary Python code. See the RasterMath cookbook recipe for detailed usage instructions.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "rasterMath",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "rasterMath",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "code",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The mathematical calculation to be performed on the selected input arrays. Select inputs in the available data sources section or use the raster layer R1, ..., R10 and vector layer V1, ..., V10. In the code snippets section you can find some prepdefined code snippets ready to use. See the RasterMath cookbook recipe for detailed usage instructions.",
        "label": "code",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "floatInput",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to cast inputs to 32-bit floating point.",
        "label": "floatInput",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "overlap",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "The number of columns and rows to read from the neighbouring blocks. Needs to be specified only when performing spatial operations, to avoid artifacts at block borders.",
        "label": "overlap",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "monolithic",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": false,
        "description": "Whether to read all data for the full extent at once, instead of block-wise processing. This may be useful for some spatially unbound operations, like segmentation or region growing, when calculating global statistics, or if RAM is not an issue at all.",
        "label": "monolithic",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "R1",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R1",
        "label": "R1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R2",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R2",
        "label": "R2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R3",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R3",
        "label": "R3",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R4",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R4",
        "label": "R4",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R5",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R5",
        "label": "R5",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R6",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R6",
        "label": "R6",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R7",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R7",
        "label": "R7",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R8",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R8",
        "label": "R8",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R9",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R9",
        "label": "R9",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "R10",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layer mapped to R10",
        "label": "R10",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V1",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V1",
        "label": "V1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V2",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V2",
        "label": "V2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V3",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V3",
        "label": "V3",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V4",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V4",
        "label": "V4",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V5",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V5",
        "label": "V5",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V6",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V6",
        "label": "V6",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V7",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V7",
        "label": "V7",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V8",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V8",
        "label": "V8",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V9",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V9",
        "label": "V9",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "V10",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Vector layer mapped to V10",
        "label": "V10",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "RS",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Raster layers mapped to RS",
        "label": "RS",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:rasterMath\ncode=$code\ngrid=$grid\nfloatInput=$floatInput\noverlap=$overlap\nmonolithic=$monolithic\nR1=$R1\nR2=$R2\nR3=$R3\nR4=$R4\nR5=$R5\nR6=$R6\nR7=$R7\nR8=$R8\nR9=$R9\nR10=$R10\nV1=$V1\nV2=$V2\nV3=$V3\nV4=$V4\nV5=$V5\nV6=$V6\nV7=$V7\nV8=$V8\nV9=$V9\nV10=$V10\nRS=$RS\noutputRaster=$outputRaster"
  },
  {
    "id": "SampleRasterLayerValues",
    "label": "Sample raster layer values",
    "version": "3.10",
    "description": "Creates a new point layer with the same attributes of the input layer and the raster values corresponding to the pixels covered by polygons or point location. The resulting point vector contains 1) all input attributes from the Locations vector, 2) attributes SAMPLE_{i}, one for each input raster band, 3) two attributes PIXEL_X, PIXEL_Y for storing the raster pixel locations (zero-based),and 4), in case of polygon locations, an attribute COVER for storing the pixel coverage (%). Note that we assume non-overlapping feature geometries! In case of overlapping geometries, split the Locations layer into non-overlapping subsets, perform the sampling for each subset individually, and finally concatenate the results.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SampleRasterLayerValues",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "SampleRasterLayerValues",
        "name": "vector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SampleRasterLayerValues",
        "name": "outputPointsData",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.gpkg"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "coverageRange",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "[50, 100]",
        "description": "Samples with polygon pixel coverage outside the given range are excluded. This parameter has no effect in case of point locations.<br/>Acceptable values:<br/> - Two comma separated numeric values, e.g. '1,10'",
        "label": "coverageRange",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SampleRasterLayerValues\nraster=$raster\nvector=$vector\ncoverageRange=$coverageRange\noutputPointsData=$outputPointsData"
  },
  {
    "id": "VrtBandMath",
    "label": "VRT band math",
    "version": "3.10",
    "description": "Create a single-band VRT raster layer specifying a VRT Python Pixel Function. Use any NumPy-based arithmetic, or even arbitrary Python code.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "VrtBandMath",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "VrtBandMath",
        "name": "outputVrt",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "bandList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "List of input bands.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "bandList",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "code",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The mathematical calculation to be performed on the selected input bands in_ar. Result must be copied to out_ar. For detailed usage information read the VRT Python Pixel Function docs.",
        "label": "code",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "dataType",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "5",
        "description": "Output data type.<br/>Available values:<br/> - 0: Byte<br/> - 1: Int16<br/> - 2: UInt16<br/> - 3: UInt32<br/> - 4: Int32<br/> - 5: Float32<br/> - 6: Float64<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "dataType",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "noData",
        "type": "REGULAR",
        "dataType": "double",
        "defaultValue": null,
        "description": "Output no data value.",
        "label": "noData",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "bandName",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Output band name.",
        "label": "bandName",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "overlap",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The number of columns and rows to read from the neighbouring blocks. Needs to be specified only when performing spatial operations, to avoid artifacts at block borders.",
        "label": "overlap",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:VrtBandMath\nraster=$raster\nbandList=$bandList\ncode=$code\ndataType=$dataType\nnoData=$noData\nbandName=$bandName\noverlap=$overlap\noutputtif=$outputtif"
  },
  {
    "id": "CreateRGBImageFromClassProbability",
    "label": "Create RGB image from class probability/fraction layer",
    "version": "3.10",
    "description": "Create an RGB image from a class fraction layer or class probability layer.The RGB pixel color of a single pixel is given by the weighted mean of the given category colors.The weights are given by class fractions/probabilities (i.e. values between 0 and 1). For example, pure pixels with cover fractions of 1 appear in its pure category color. A mixed-pixel with a 50% fractions in two categories colored in red and green,appears in a dull yellow ( 0.5 x (255, 0, 0) + 0.5 x (0, 255, 0) = (127, 127, 0) ).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "CreateRGBImageFromClassProbability",
        "name": null,
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateRGBImageFromClassProbability",
        "name": "outputRGBImage",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "colors",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Comma separated list of hex-color strings (e.g. ‘#FF0000’ for red) representing (pure) category colors, one color for each band in the given class probability/fraction layer. If not specified, colors have to be specified by a categorized layer (Colors from categorized layer).",
        "label": "colors",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "colorsLayer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A categorized layer with (pure) category colors, one category for each band in the given class probability/fraction layer. If not specified, colors have to be specified by list (Colors).",
        "label": "colorsLayer",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateRgbImageFromClassProbabilityfractionLayer\nprobability=$probability\ncolors=$colors\ncolorsLayer=$colorsLayer\noutputRGBImage=$outputRGBImage"
  },
  {
    "id": "SaveRasterLayerAs",
    "label": "Save raster layer as",
    "version": "3.10",
    "description": "Saves a raster layer as a GeoTiff, ENVI or VRT file. This is a slimmed down version of the more powerful 'Translate raster layer' algorithm.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SaveRasterLayerAs",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SaveRasterLayerAs",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "copyMetadata",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to copy metadata from source to destination.",
        "label": "copyMetadata",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "copyStyle",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to copy style from source to destination.",
        "label": "copyStyle",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "creationProfile",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Output format and creation options.",
        "label": "creationProfile",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SaveRasterLayerAs\nraster=$raster\ncopyMetadata=$copyMetadata\ncopyStyle=$copyStyle\ncreationProfile=$creationProfile\noutputRaster=$outputRaster"
  },
  {
    "id": "TranslateCategorizedRasterLayer",
    "label": "Translate categorized raster layer",
    "version": "3.10",
    "description": "Translates categorized raster layer into target grid. Resampling is done via a two-step majority voting approach. First, the categorized raster layer is resampled at x10 finer resolution, and subsequently aggregated back to the target resolution using majority voting. This approach leads to pixel-wise class decisions that are accurate to the percent.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "TranslateCategorizedRasterLayer",
        "name": "categorizedRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "TranslateCategorizedRasterLayer",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "TranslateCategorizedRasterLayer",
        "name": "outputTranslatedCategorizedRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "majorityVoting",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to use majority voting. Turn off to use simple nearest neighbour resampling, which is much faster, but may result in highly inaccurate decisions.",
        "label": "majorityVoting",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:TranslateCategorizedRasterLayer\ncategorizedRaster=$categorizedRaster\ngrid=$grid\nmajorityVoting=$majorityVoting\noutputTranslatedCategorizedRaster=$outputTranslatedCategorizedRaster"
  },
  {
    "id": "TranslateRasterLayer",
    "label": "Translate raster layer",
    "version": "3.10",
    "description": "Convert raster data between different formats, potentially performing some operations like spatial subsetting, spatial resampling, reprojection, band subsetting, band reordering, data scaling, no data value specification, and data type conversion.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "TranslateRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "TranslateRasterLayer",
        "name": "outputTranslatedRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "bandList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Selected bands.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "bandList",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "grid",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Grid",
        "label": "grid",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "copyMetadata",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Copy metadata",
        "label": "copyMetadata",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "copyStyle",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Copy style",
        "label": "copyStyle",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "excludeBadBands",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Exclude bad bands",
        "label": "excludeBadBands",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "writeEnviHeader",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Write ENVI header",
        "label": "writeEnviHeader",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "spectralSubset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Spectral raster layer for band subsetting",
        "label": "spectralSubset",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "spectralBandList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Selected spectral bands.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "spectralBandList",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "offset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Data offset value",
        "label": "offset",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "scale",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Data gain/scale value",
        "label": "scale",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "extent",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Spatial extent.<br/>Acceptable values:<br/> - A comma delimited string of x min, x max, y min, y max. E.g. '4,10,101,105'<br/> - Path to a layer. The extent of the layer is used.",
        "label": "extent",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "sourceColumns",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Column subset.<br/>Acceptable values:<br/> - Two comma separated numeric values, e.g. '1,10'",
        "label": "sourceColumns",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "sourceRows",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Row subset.<br/>Acceptable values:<br/> - Two comma separated numeric values, e.g. '1,10'",
        "label": "sourceRows",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "resampleAlg",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Resample algorithm.<br/>Available values:<br/> - 0: NearestNeighbour<br/> - 1: Bilinear<br/> - 2: Cubic<br/> - 3: CubicSpline<br/> - 4: Lanczos<br/> - 5: Average<br/> - 6: Mode<br/> - 7: Min<br/> - 8: Q1<br/> - 9: Med<br/> - 10: Q3<br/> - 11: Max<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "resampleAlg",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "sourceNoData",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Source no data value",
        "label": "sourceNoData",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "noData",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "No data value",
        "label": "noData",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "unsetSourceNoData",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Unset source no data value",
        "label": "unsetSourceNoData",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "unsetNoData",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Unset no data value",
        "label": "unsetNoData",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "workingType",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Working Data type. <br/>Available values:<br/> - 0: Byte<br/> - 1: Int16<br/> - 2: UInt16<br/> - 3: UInt32<br/> - 4: Int32<br/> - 5: Float32<br/> - 6: Float64<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "workingType",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataType",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Data type. <br/>Available values:<br/> - 0: Byte<br/> - 1: Int16<br/> - 2: UInt16<br/> - 3: UInt32<br/> - 4: Int32<br/> - 5: Float32<br/> - 6: Float64<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "dataType",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "creationProfile",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Output options",
        "label": "creationProfile",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:TranslateRasterLayer\nraster=$raster\nbandList=$bandList\ngrid=$grid\ncopyMetadata=$copyMetadata\ncopyStyle=$copyStyle\nexcludeBadBands=$excludeBadBands\nwriteEnviHeader=$writeEnviHeader\nspectralSubset=$spectralSubset\nspectralBandList=$spectralBandList\noffset=$offset\nscale=$scale\nextent=$extent\nsourceColumns=$sourceColumns\nsourceRows=$sourceRows\nresampleAlg=$resampleAlg\nsourceNoData=$sourceNoData\nnoData=$noData\nunsetSourceNoData=$unsetSourceNoData\nunsetNoData=$unsetNoData\nworkingType=$workingType\ndataType=$dataType\ncreationProfile=$creationProfile\noutputTranslatedRaster=$outputTranslatedRaster"
  },
  {
    "id": "CreateGrid",
    "label": "Create grid",
    "version": "3.10",
    "description": "Create an empty raster that can be used as a grid.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
    ],
    "targets": [
      {
        "id": null,
        "parentId": "CreateGrid",
        "name": "outputGrid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "crs",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Destination coordinate reference system.<br/>Acceptable values:<br/> - CRS as an auth ID (e.g. 'EPSG:3111')<br/> - CRS as a PROJ4 string (e.g. 'PROJ4:...')<br/> - CRS as a WKT string (e.g. 'WKT:...')<br/> - Path to a layer. The CRS of the layer is used.",
        "label": "crs",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "extent",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Destination extent.<br/>Acceptable values:<br/> - A comma delimited string of x min, x max, y min, y max. E.g. '4,10,101,105'<br/> - Path to a layer. The extent of the layer is used.",
        "label": "extent",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "unit",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Units to use when defining target raster size/resolution.<br/>Available values:<br/> - 0: Pixels<br/> - 1: Georeferenced units<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "unit",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "width",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Target width if size units is 'Pixels', or horizontal resolution if size units is 'Georeferenced units'.",
        "label": "width",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "hight",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": 0,
        "description": "Target height if size units is 'Pixels', or vertical resolution if size units is 'Georeferenced units'.",
        "label": "hight",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:CreateGrid\ncrs=$crs\nextent=$extent\nunit=$unit\nwidth=$width\nhight=$hight\noutputGrid=$outputGrid"
  },
  {
    "id": "StackRasterLayers",
    "label": "Stack raster layers",
    "version": "3.10",
    "description": "Stack raster layers and store the result as a VRT file.This is a slimmed down version of the more powerful/complicated GDAL 'Build virtual raster' algorithm. If you also want to delete or rearrange individual bands, just use the 'Subset raster layer bands' algorithm afterwards.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "StackRasterLayers",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "StackRasterLayers",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "grid",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "",
        "label": "grid",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "band",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "",
        "label": "band",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:StackRasterLayers\nRasters=$Rasters\ngrid=$grid\nband=$band\noutputRaster=$outputRaster"
  },
  {
    "id": "SubsetRasterLayerBands",
    "label": "Subset raster layer bands",
    "version": "3.10",
    "description": "Subsets raster layer bands and stores the result as a VRT file.This is a slimmed down version of the more powerful 'Translate raster layer' algorithm.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SubsetRasterLayerBands",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SubsetRasterLayerBands",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.vrt"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "bandList",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Bands to subset and rearrange. An empty selection defaults to all bands in native order.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "bandList",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "excludeBadBands",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to exclude bad bands.",
        "label": "excludeBadBands",
        "notNull": true,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SubsetRasterLayerBands\nraster=$raster\nbandList=$bandList\nexcludeBadBands=$excludeBadBands\noutputRaster=$outputRaster"
  },
  {
    "id": "GeolocateRasterLayer",
    "label": "Geolocate raster layer",
    "version": "3.10",
    "description": "Geolocate a raster layer using geolocation arrays. See Geolocation Arrays in the GDAL documentation for details on the concept and parameters.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "GeolocateRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "GeolocateRasterLayer",
        "name": "xRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "GeolocateRasterLayer",
        "name": "yRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "GeolocateRasterLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "grid",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The destination grid. If skipped, the grid CRS is set to the CRS of the geolocation arrays, extent and resolution is controlled by gdal.Warp defaults.",
        "label": "grid",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "crs",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "EPSG:4326",
        "description": "The coordinate reference system of the geolocation arrays.<br/>Acceptable values:<br/> - CRS as an auth ID (e.g. 'EPSG:3111')<br/> - CRS as a PROJ4 string (e.g. 'PROJ4:...')<br/> - CRS as a WKT string (e.g. 'WKT:...')<br/> - Path to a layer. The CRS of the layer is used.",
        "label": "crs",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "noDataValue",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Value used to fill no data regions introduced by warping.",
        "label": "noDataValue",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "xBand",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The x coordinates band.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "xBand",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "yBand",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "The y coordinates band.<br/>Acceptable values:<br/> - Integer value representing an existing raster band number",
        "label": "yBand",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "pixelOffset",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Pixel offset into geo-located data of left geolocation pixel.",
        "label": "pixelOffset",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "lineOffset",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Line offset into geo-located data of top geolocation pixel.",
        "label": "lineOffset",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "pixelStep",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Each geolocation pixel represents this many geolocated pixels.",
        "label": "pixelStep",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "lineStep",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Each geolocation pixel represents this many geolocated lines",
        "label": "lineStep",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:GeolocateRasterLayer\nraster=$raster\nxRaster=$xRaster\nyRaster=$yRaster\ngrid=$grid\ncrs=$crs\nnoDataValue=$noDataValue\nxBand=$xBand\nyBand=$yBand\npixelOffset=$pixelOffset\nlineOffset=$lineOffset\npixelStep=$pixelStep\nlineStep=$lineStep\noutputGeolocatedRaster=$outputGeolocatedRaster"
  },
  {
    "id": "FitCatBoostRegressor",
    "label": "Fit CatBoost Regressor",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for CatBoost regressor.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitCatBoostRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitCatBoostRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from catboost import CatBoostRegressor;regressor = CatBoostRegressor(n_estimators=100)",
        "description": "Scikit-learn python code. See CatBoostRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitCatboostregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitGaussianProcessRegressor",
    "label": "Fit Gaussian Process Regressor",
    "version": "3.10",
    "description": "Gaussian process regression (GPR).",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitGaussianProcessRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitGaussianProcessRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.gaussian_process import GaussianProcessRegressor;from sklearn.gaussian_process.kernels import RBF;gpr = GaussianProcessRegressor(RBF());regressor = make_pipeline(StandardScaler(), gpr)",
        "description": "Scikit-learn python code. See GaussianProcessRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitGaussianprocessregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitGenericRegressor",
    "label": "Fit generic regressor",
    "version": "3.10",
    "description": "A generic regressor.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitGenericRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitGenericRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.dummy import DummyRegressor;regressor = DummyRegressor()",
        "description": "Scikit-learn python code.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitGenericRegressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitKernelRidge",
    "label": "Fit Kernel Ridge",
    "version": "3.10",
    "description": "Kernel ridge regression. Kernel ridge regression (KRR) combines ridge regression (linear least squares with l2-norm regularization) with the kernel trick. It thus learns a linear function in the space induced by the respective kernel and the data. For non-linear kernels, this corresponds to a non-linear function in the original space. The form of the model learned by KRR is identical to support vector regression (SVR). However, different loss functions are used: KRR uses squared error loss while support vector regression uses epsilon-insensitive loss, both combined with l2 regularization. In contrast to SVR, fitting a KRR model can be done in closed-form and is typically faster for medium-sized datasets. On the other hand, the learned model is non-sparse and thus slower than SVR, which learns a sparse model for epsilon > 0, at prediction-time.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitKernelRidge",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitKernelRidge",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.model_selection import GridSearchCV;from sklearn.preprocessing import StandardScaler;from sklearn.kernel_ridge import KernelRidge;krr = KernelRidge();param_grid = {'kernel': ['rbf'], 'gamma': [0.001, 0.01, 0.1, 1, 10, 100, 1000], 'alpha': [0.001, 0.01, 0.1, 1, 10, 100, 1000]};tunedKRR = GridSearchCV(cv=3, estimator=krr, scoring='neg_mean_absolute_error', param_grid=param_grid);regressor = make_pipeline(StandardScaler(), tunedKRR)",
        "description": "Scikit-learn python code. See KernelRidge for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitKernelridge\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitLGBMRegressor",
    "label": "Fit LGBM Regressor",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for LightGBM regressor.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLGBMRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLGBMRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from lightgbm import LGBMRegressor;regressor = LGBMRegressor(n_estimators=100)",
        "description": "Scikit-learn python code. See LGBMRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLgbmregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitLinearRegression",
    "label": "Fit LinearRegression",
    "version": "3.10",
    "description": "Ordinary least squares Linear Regression. LinearRegression fits a linear model with coefficients w = (w1, ..., wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLinearRegression",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLinearRegression",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.linear_model import LinearRegression;linearRegression = LinearRegression();regressor = make_pipeline(StandardScaler(), linearRegression)",
        "description": "Scikit-learn python code. See LinearRegression for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLinearregression\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitLinearSVR",
    "label": "Fit Linear SVR",
    "version": "3.10",
    "description": "Linear Support Vector Regression. Similar to SVR with parameter kernel=’linear’, but implemented in terms of liblinear rather than libsvm, so it has more flexibility in the choice of penalties and loss functions and should scale better to large numbers of samples.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitLinearSVR",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitLinearSVR",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.model_selection import GridSearchCV;from sklearn.multioutput import MultiOutputRegressor;from sklearn.preprocessing import StandardScaler;from sklearn.svm import LinearSVR;svr = LinearSVR();param_grid = {'epsilon': [0.], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]};tunedSVR = GridSearchCV(cv=3, estimator=svr, scoring='neg_mean_absolute_error', param_grid=param_grid);scaledAndTunedSVR = make_pipeline(StandardScaler(), tunedSVR);regressor = MultiOutputRegressor(scaledAndTunedSVR)",
        "description": "Scikit-learn python code. See LinearSVR for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitLinearsvr\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitPLSRegression",
    "label": "Fit PLS Regression",
    "version": "3.10",
    "description": "Partial Least Squares regression.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitPLSRegression",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitPLSRegression",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.cross_decomposition import PLSRegression;regressor = PLSRegression(n_components=2)",
        "description": "Scikit-learn python code. See PLSRegression for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitPlsregression\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitRandomForestRegressor",
    "label": "Fit Random Forest Regressor",
    "version": "3.10",
    "description": "A random forest regressor. A random forest is a meta estimator that fits a number of classifying decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. The sub-sample size is controlled with the max_samples parameter if bootstrap=True (default), otherwise the whole dataset is used to build each tree.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitRandomForestRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitRandomForestRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.ensemble import RandomForestRegressor;regressor = RandomForestRegressor(n_estimators=100, oob_score=True)",
        "description": "Scikit-learn python code. See RandomForestRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitRandomforestregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitSVRPolynomialKernel",
    "label": "Fit SVR (polynomial kernel)",
    "version": "3.10",
    "description": "Epsilon-Support Vector Regression. The free parameters in the model are C and epsilon. The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitSVRPolynomialKernel",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitSVRPolynomialKernel",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.model_selection import GridSearchCV;from sklearn.preprocessing import StandardScaler;from sklearn.svm import SVR;svr = SVR();param_grid = {'kernel': ['poly'], 'epsilon': [0.], 'coef0': [0], 'degree': [3], 'gamma': [0.001, 0.01, 0.1, 1, 10, 100, 1000], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]};tunedSVR = GridSearchCV(cv=3, estimator=svr, scoring='neg_mean_absolute_error', param_grid=param_grid);regressor = make_pipeline(StandardScaler(), tunedSVR)",
        "description": "Scikit-learn python code. See SVR, GridSearchCV, StandardScaler for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitSvrPolynomialKernel\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitSVRRBFKernel",
    "label": "Fit SVR (RBF kernel)",
    "version": "3.10",
    "description": "Epsilon-Support Vector Regression. The free parameters in the model are C and epsilon. The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitSVRRBFKernel",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitSVRRBFKernel",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.model_selection import GridSearchCV;from sklearn.preprocessing import StandardScaler;from sklearn.svm import SVR;svr = SVR();param_grid = {'kernel': ['rbf'], 'epsilon': [0.], 'gamma': [0.001, 0.01, 0.1, 1, 10, 100, 1000], 'C': [0.001, 0.01, 0.1, 1, 10, 100, 1000]};tunedSVR = GridSearchCV(cv=3, estimator=svr, scoring='neg_mean_absolute_error', param_grid=param_grid);regressor = make_pipeline(StandardScaler(), tunedSVR)",
        "description": "Scikit-learn python code. See SVR, GridSearchCV, StandardScaler for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitSvrRbfKernel\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitXGBRegressor",
    "label": "Fit XGB Regressor",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for XGBoost regression.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitXGBRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitXGBRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from xgboost import XGBRegressor;regressor = XGBRegressor(n_estimators=100)",
        "description": "Scikit-learn python code. See XGBRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitXgbregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "FitXGBRFRegressor",
    "label": "Fit XGBRFRegressor",
    "version": "3.10",
    "description": "Implementation of the scikit-learn API for XGBoost random forest regression.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitXGBRFRegressor",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitXGBRFRegressor",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from xgboost import XGBRFRegressor;regressor = XGBRFRegressor(n_estimators=100)",
        "description": "Scikit-learn python code. See XGBRFRegressor for information on different parameters.",
        "label": "regressor",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitXgbrfregressor\nregressor=$regressor\ndataset=$dataset\noutputRegressor=$outputRegressor"
  },
  {
    "id": "PredictRegressionLayer",
    "label": "Predict regression layer",
    "version": "3.10",
    "description": "Uses a fitted regressor to predict a regression layer from a raster layer with features.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "PredictRegressionLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "PredictRegressionLayer",
        "name": "regressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "PredictRegressionLayer",
        "name": "outputRegression",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:PredictRegressionLayer\nraster=$raster\nregressor=$regressor\noutputRegression=$outputRegression"
  },
  {
    "id": "ReceiverOperatingROC",
    "label": "Receiver operating characteristic (ROC) and detection error tradeoff (DET) curves",
    "version": "3.10",
    "description": "Compute receiver operating characteristic (ROC) and detection error tradeoff (DET) curves. For more details see the Scikit-Learn user guide: Receiver operating characteristic (ROC) and Detection error tradeoff (DET). Note that observed classes and predicted class probabilities are matched by name.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "ReceiverOperatingROC",
        "name": "regression",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "ReceiverOperatingROC",
        "name": "reference",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "ReceiverOperatingROC",
        "name": "outRocCurve",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "output.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:ReceiverOperatingCharacteristicRocAndDetectionErrorTradeoffDetCurves\nregression=$regression\nreference=$reference\nopenReport=false\noutRocCurve=$outRocCurve"
  },
  {
    "id": "RegressionAccuracyReport",
    "label": "Regression layer accuracy report",
    "version": "3.10",
    "description": "Estimates map accuracy.We use the formulars as described in Scikit-Learn Regression metrics user guide. Observed and predicted target variables are matched by name.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RegressionAccuracyReport",
        "name": "regression",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RegressionAccuracyReport",
        "name": "reference",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RegressionAccuracyReport",
        "name": "outRegressionPerformance",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "OTHER",
          "location": "output.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:RegressionLayerAccuracyReport\nregression=$regression\nreference=$reference\nopenReport=false\noutRegressionPerformance=$outRegressionPerformance"
  },
  {
    "id": "RegressionWorkflow",
    "label": "Regression workflow",
    "version": "3.10",
    "description": "The regression workflow combines regressor fitting and map prediction.Optionally, the cross-validation performance of the regressor can be assessed.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "regressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.html"
        }
      },
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      },
      {
        "id": null,
        "parentId": "RegressionWorkflow",
        "name": "outputRegression",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "nfold",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 10,
        "description": "The number of folds used for assessing cross-validation performance. Will be ignored, if the cross-validation performance assessment is skipped.",
        "label": "nfold",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RegressionWorkflow\ndataset=$dataset\nregressor=$regressor\nraster=$raster\nnfold=$nfold\nopenReport=false\noutputRegressorPerformance=$outputRegressorPerformance\noutputRegressor=$outputRegressor\noutputRegression=$outputRegression\n"
  },
  {
    "id": "RegressorPerformanceReport",
    "label": "Regressor performance report",
    "version": "3.10",
    "description": "Evaluates regressor performance.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RegressorPerformanceReport",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RegressorPerformanceReport",
        "name": "regressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RegressorPerformanceReport",
        "name": "outputRegressor",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.html"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "nfold",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 10,
        "description": "The number of folds used for assessing cross-validation performance. Will be ignored, if the cross-validation performance assessment is skipped.",
        "label": "nfold",
        "notNull": true,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RegressorPerformanceReport\nregressor=$regressor\ndataset=$dataset\nnfold=$nfold\nopenReport=false\noutputRegressorPerformance=$outputRegressorPerformance"
  },
  {
    "id": "SpectralIndexOptimizer",
    "label": "Spectral Index Optimizer",
    "version": "3.10",
    "description": "This algorithm finds the optimal two-feature index by modelling a target variable via linear regression.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralIndexOptimizer",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralIndexOptimizer",
        "name": "outScoreMatrix",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "formular",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "(A-B) / (A+B)",
        "description": "The formular with variable features A and B to be optimized, and up to three fixed features F1, F2 and F3.",
        "label": "formular",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "maxFeatures",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Limit the number of features to be evaluated. Default is to use all features.",
        "label": "maxFeatures",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "f1",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Specify to use a fixed feature F1 in the formular.",
        "label": "f1",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "f2",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Specify to use a fixed feature F2 in the formular.",
        "label": "f2",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "f3",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": null,
        "description": "Specify to use a fixed feature F3 in the formular.",
        "label": "f3",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "outScoreMatrix",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Output score matrix",
        "label": "outScoreMatrix",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralIndexOptimizer\ndataset=$dataset\nformular=$formular\nmaxFeatures=$maxFeatures\nf1=$f1\nf2=$f2\nf3=$f3\noutScoreMatrix=$outScoreMatrix"
  },
  {
    "id": "SpectralResamplingToCustomSensor",
    "label": "Spectral resampling (to custom sensor)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToCustomSensor",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToCustomSensor",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict(); responses[460] = 5.8",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToCustomSensor\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToDesisHsi",
    "label": "Spectral resampling (to DESIS HSI)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the DESIS mission website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToDesisHsi",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToDesisHsi",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();wavelength = [402.0,404.2,406.8,409.3,411.8,414.3,416.9,419.4,422.0,424.6,427.3,429.8,432.4,434.9,437.5,439.9,442.5,445.1,447.8,450.3,452.9,455.6,458.2,460.7,463.3,465.8,468.3,470.7,473.4,475.9,478.5,481.3,483.8,486.4,489.0,491.6,494.0,496.5,499.2,501.8,504.3,506.9,509.5,512.2,514.7,517.2,519.6,522.2,524.7,527.3,529.7,532.3,534.9,537.5,540.2,542.7,545.2,547.7,550.3,552.9,555.5,558.1,560.6,563.2,565.8,568.4,571.0,573.5,576.1,578.6,581.1,583.7,586.3,588.8,591.3,594.0,596.6,599.1,601.6,604.2,606.8,609.2,611.8,614.3,616.9,619.5,622.1,624.7,627.2,629.7,632.2,634.7,637.2,639.8,642.3,644.9,647.5,650.0,652.6,655.2,657.7,660.2,662.8,665.3,667.9,670.5,673.1,675.8,678.4,680.9,683.5,685.9,688.4,690.9,693.5,696.2,698.8,701.5,703.9,706.7,709.4,711.8,714.0,716.4,718.9,721.6,724.2,726.9,729.4,732.1,734.4,736.9,739.5,742.0,744.5,747.2,749.7,752.3,755.2,757.7,760.3,763.0,765.0,767.5,770.3,772.7,775.4,778.0,780.5,783.0,785.6,788.2,790.6,793.1,795.9,798.4,801.2,804.0,806.7,809.1,811.7,814.3,816.9,819.8,822.8,824.2,827.2,829.2,832.2,834.9,836.7,840.1,842.0,844.7,847.7,850.0,852.4,855.4,857.9,860.3,862.9,865.4,868.0,870.6,873.2,875.8,878.8,881.5,883.1,885.3,888.1,890.9,894.1,896.0,898.3,901.2,903.7,906.0,908.7,911.6,914.8,916.6,918.4,921.0,923.9,927.1,929.6,931.9,934.5,937.3,939.4,942.0,944.7,947.3,949.6,951.9,954.2,957.3,959.6,962.3,965.5,968.1,970.4,972.9,976.0,978.7,980.0,981.9,984.8,988.9,991.6,993.1,995.6,997.9,999.5];fwhm = [2.4,3.6,3.8,3.8,3.6,3.8,3.4,3.4,3.6,3.6,3.4,3.4,3.2,3.2,3.0,3.2,3.4,3.2,3.4,3.4,3.4,3.6,3.4,3.4,3.2,3.2,3.4,3.2,3.2,3.4,3.4,3.4,3.2,3.2,3.2,3.2,3.2,3.2,3.4,3.4,3.4,3.6,3.6,3.4,3.4,3.4,3.4,3.4,3.4,3.6,3.4,3.4,3.6,3.6,3.4,3.4,3.6,3.6,3.6,3.4,3.4,3.4,3.6,3.6,3.6,3.6,3.6,3.6,3.4,3.4,3.4,3.4,3.6,3.6,3.6,3.6,3.6,3.4,3.6,3.6,3.4,3.4,3.6,3.4,3.4,3.4,3.4,3.4,3.4,3.4,3.2,3.4,3.4,3.4,3.4,3.6,3.6,3.4,3.6,3.4,3.4,3.4,3.4,3.4,3.4,3.4,3.6,3.6,3.4,3.4,3.4,3.4,3.2,3.4,3.4,3.4,3.6,3.6,3.8,3.6,3.6,4.0,4.0,3.8,3.4,3.4,3.6,3.4,3.4,3.2,3.2,3.4,3.4,3.2,3.4,3.4,3.4,3.4,3.6,3.4,3.4,3.6,3.0,3.4,3.4,3.4,3.4,3.6,3.2,3.4,3.2,3.4,3.2,3.4,3.4,3.4,3.2,3.0,3.0,3.0,3.0,3.0,3.2,3.6,3.2,3.0,3.6,2.8,3.6,2.6,3.0,3.4,2.8,3.4,3.4,3.0,3.2,3.2,3.2,3.0,3.4,3.2,3.4,3.4,3.4,3.6,4.0,3.0,3.0,3.4,3.6,3.6,3.6,3.2,3.2,3.6,3.6,3.0,4.0,4.0,3.8,3.0,3.6,4.0,3.6,3.4,3.4,3.2,3.8,3.4,3.2,3.8,3.6,3.6,3.6,3.0,3.6,3.4,3.4,3.4,3.6,3.8,3.6,3.4,4.8,3.6,2.8,4.0,6.6,4.2,3.4,3.0,3.4,3.4,3.0]; exec(\\\"for w,f in zip(wavelength,fwhm): responses[w] = f\\\")",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToDesisHsi\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToEnmap",
    "label": "Spectral resampling (to EnMAP)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the EnMAP mission website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToEnmap",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToEnmap",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();wavelength = [460,465,470,475,479,484,489,494,499,503,508,513,518,523,528,533,538,543,549,554,559,565,570,575,581,587,592,598,604,610,616,622,628,634,640,646,653,659,665,672,679,685,692,699,706,713,720,727,734,741,749,756,763,771,778,786,793,801,809,817,824,832,840,848,856,864,872,880,888,896,915,924,934,944,955,965,975,986,997,1007,1018,1029,1040,1051,1063,1074,1086,1097,1109,1120,1132,1144,1155,1167,1179,1191,1203,1215,1227,1239,1251,1263,1275,1287,1299,1311,1323,1522,1534,1545,1557,1568,1579,1590,1601,1612,1624,1634,1645,1656,1667,1678,1689,1699,1710,1721,1731,1742,1752,1763,1773,1783,2044,2053,2062,2071,2080,2089,2098,2107,2115,2124,2133,2141,2150,2159,2167,2176,2184,2193,2201,2210,2218,2226,2234,2243,2251,2259,2267,2275,2283,2292,2300,2308,2315,2323,2331,2339,2347,2355,2363,2370,2378,2386,2393,2401,2409];fwhm = [5.8,5.8,5.8,5.8,5.8,5.8,5.8,5.8,5.8,5.8,5.9,5.9,6.0,6.0,6.1,6.1,6.2,6.2,6.3,6.4,6.4,6.5,6.6,6.6,6.7,6.8,6.9,6.9,7.0,7.1,7.2,7.3,7.3,7.4,7.5,7.6,7.7,7.8,7.9,7.9,8.0,8.1,8.2,8.3,8.4,8.4,8.5,8.6,8.7,8.7,8.8,8.9,8.9,9.0,9.1,9.1,9.2,9.3,9.3,9.4,9.4,9.5,9.5,9.6,9.6,9.6,9.6,9.7,9.7,9.7,11.8,11.9,12.1,12.2,12.4,12.5,12.7,12.8,12.9,13.1,13.2,13.3,13.4,13.5,13.6,13.7,13.8,13.9,14.0,14.0,14.1,14.1,14.2,14.2,14.3,14.3,14.3,14.4,14.4,14.4,14.4,14.4,14.4,14.4,14.4,14.4,14.4,13.7,13.6,13.6,13.5,13.5,13.4,13.4,13.3,13.2,13.2,13.1,13.1,13.0,12.9,12.9,12.8,12.8,12.7,12.7,12.6,12.5,12.5,12.4,12.4,12.3,10.9,10.8,10.8,10.7,10.7,10.6,10.6,10.5,10.5,10.4,10.4,10.4,10.3,10.3,10.2,10.2,10.1,10.1,10.1,10.0,10.0,9.9,9.9,9.9,9.8,9.8,9.7,9.7,9.7,9.6,9.6,9.6,9.5,9.5,9.4,9.4,9.4,9.3,9.3,9.3,9.2,9.2,9.1,9.1,9.1];exec(\\\"for w,f in zip(wavelength,fwhm): responses[w] = f\\\")",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToEnmap\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToLandsat45Tm",
    "label": "Spectral resampling (to Landsat 4/5 TM)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the Landsat missions website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat45Tm",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat45Tm",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();responses['Blue'] = [(421,0.001),(422,0.001),(423,0.001),(424,0.001),(425,0.001),(426,0.002),(427,0.002),(428,0.002),(429,0.003),(430,0.003),(431,0.005),(432,0.007),(433,0.01),(434,0.013),(435,0.017),(436,0.02),(437,0.025),(438,0.031),(439,0.037),(440,0.042),(441,0.048),(442,0.053),(443,0.059),(444,0.064),(445,0.07),(446,0.083),(447,0.121),(448,0.172),(449,0.273),(450,0.372),(451,0.442),(452,0.514),(453,0.579),(454,0.628),(455,0.711),(456,0.732),(457,0.742),(458,0.75),(459,0.755),(460,0.756),(461,0.766),(462,0.776),(463,0.786),(464,0.797),(465,0.807),(466,0.812),(467,0.817),(468,0.822),(469,0.827),(470,0.829),(471,0.831),(472,0.833),(473,0.835),(474,0.838),(475,0.846),(476,0.853),(477,0.861),(478,0.868),(479,0.876),(480,0.883),(481,0.886),(482,0.888),(483,0.891),(484,0.893),(485,0.896),(486,0.898),(487,0.901),(488,0.903),(489,0.905),(490,0.908),(491,0.918),(492,0.928),(493,0.938),(494,0.948),(495,0.952),(496,0.956),(497,0.961),(498,0.965),(499,0.97),(500,0.979),(501,0.987),(502,0.994),(503,1.0),(504,0.999),(505,0.99),(506,0.963),(507,0.936),(508,0.909),(509,0.881),(510,0.852),(511,0.824),(512,0.81),(513,0.796),(514,0.779),(515,0.756),(516,0.707),(517,0.596),(518,0.497),(519,0.413),(520,0.329),(521,0.245),(522,0.137),(523,0.105),(524,0.094),(525,0.083),(526,0.072),(527,0.061),(528,0.055),(529,0.052),(530,0.049),(531,0.045),(532,0.041),(533,0.038),(534,0.034),(535,0.031),(536,0.027),(537,0.024),(538,0.022),(539,0.019),(540,0.017),(541,0.015),(542,0.013),(543,0.011),(544,0.01),(545,0.009),(546,0.007),(547,0.006),(548,0.006),(549,0.006),(550,0.005),(551,0.005),(552,0.005),(553,0.005),(554,0.005),(555,0.004),(556,0.004),(557,0.004),(558,0.004),(559,0.004),(560,0.003),(561,0.003),(562,0.003),(563,0.003),(564,0.002),(565,0.002),(566,0.002),(567,0.002),(568,0.002),(569,0.001),(570,0.001)];responses['Green'] = [(502,0.002),(503,0.003),(504,0.007),(505,0.009),(506,0.011),(507,0.014),(508,0.016),(509,0.019),(510,0.022),(511,0.024),(512,0.027),(513,0.03),(514,0.032),(515,0.035),(516,0.05),(517,0.066),(518,0.091),(519,0.12),(520,0.152),(521,0.191),(522,0.231),(523,0.271),(524,0.312),(525,0.353),(526,0.392),(527,0.43),(528,0.468),(529,0.507),(530,0.537),(531,0.561),(532,0.577),(533,0.591),(534,0.605),(535,0.619),(536,0.633),(537,0.647),(538,0.661),(539,0.675),(540,0.69),(541,0.7),(542,0.711),(543,0.721),(544,0.732),(545,0.743),(546,0.753),(547,0.764),(548,0.775),(549,0.786),(550,0.797),(551,0.803),(552,0.809),(553,0.815),(554,0.821),(555,0.826),(556,0.832),(557,0.837),(558,0.843),(559,0.848),(560,0.854),(561,0.859),(562,0.865),(563,0.871),(564,0.873),(565,0.874),(566,0.875),(567,0.877),(568,0.878),(569,0.879),(570,0.88),(571,0.881),(572,0.882),(573,0.883),(574,0.884),(575,0.885),(576,0.886),(577,0.887),(578,0.891),(579,0.896),(580,0.9),(581,0.905),(582,0.909),(583,0.914),(584,0.932),(585,0.944),(586,0.954),(587,0.963),(588,0.971),(589,0.977),(590,0.982),(591,0.988),(592,0.994),(593,0.999),(594,1.0),(595,0.999),(596,0.998),(597,0.995),(598,0.98),(599,0.964),(600,0.949),(601,0.927),(602,0.894),(603,0.862),(604,0.829),(605,0.796),(606,0.747),(607,0.672),(608,0.597),(609,0.521),(610,0.467),(611,0.413),(612,0.359),(613,0.304),(614,0.249),(615,0.206),(616,0.181),(617,0.156),(618,0.131),(619,0.108),(620,0.097),(621,0.087),(622,0.076),(623,0.066),(624,0.055),(625,0.052),(626,0.049),(627,0.045),(628,0.042),(629,0.039),(630,0.036),(631,0.032),(632,0.029),(633,0.026),(634,0.023),(635,0.021),(636,0.019),(637,0.017),(638,0.015),(639,0.013),(640,0.011),(641,0.01),(642,0.009),(643,0.008),(644,0.006),(645,0.005),(646,0.003),(647,0.002),(648,0.001)];responses['Red'] = [(563,0.001),(564,0.001),(565,0.001),(566,0.001),(567,0.001),(568,0.001),(569,0.002),(570,0.002),(571,0.002),(572,0.002),(573,0.002),(574,0.002),(575,0.002),(576,0.002),(577,0.002),(578,0.002),(579,0.002),(580,0.002),(581,0.002),(582,0.002),(583,0.002),(584,0.002),(585,0.002),(586,0.002),(587,0.002),(588,0.002),(589,0.002),(590,0.003),(591,0.003),(592,0.003),(593,0.004),(594,0.004),(595,0.004),(596,0.005),(597,0.006),(598,0.007),(599,0.008),(600,0.009),(601,0.011),(602,0.014),(603,0.016),(604,0.019),(605,0.023),(606,0.027),(607,0.03),(608,0.034),(609,0.038),(610,0.041),(611,0.045),(612,0.062),(613,0.081),(614,0.101),(615,0.12),(616,0.14),(617,0.16),(618,0.18),(619,0.24),(620,0.327),(621,0.414),(622,0.449),(623,0.471),(624,0.492),(625,0.514),(626,0.535),(627,0.557),(628,0.579),(629,0.601),(630,0.623),(631,0.65),(632,0.687),(633,0.737),(634,0.787),(635,0.803),(636,0.818),(637,0.835),(638,0.849),(639,0.86),(640,0.871),(641,0.883),(642,0.894),(643,0.906),(644,0.912),(645,0.917),(646,0.922),(647,0.928),(648,0.933),(649,0.939),(650,0.944),(651,0.943),(652,0.942),(653,0.942),(654,0.941),(655,0.94),(656,0.939),(657,0.938),(658,0.937),(659,0.936),(660,0.935),(661,0.937),(662,0.939),(663,0.943),(664,0.948),(665,0.954),(666,0.959),(667,0.965),(668,0.97),(669,0.975),(670,0.979),(671,0.983),(672,0.987),(673,0.99),(674,0.997),(675,0.996),(676,0.998),(677,1.0),(678,0.998),(679,0.996),(680,0.994),(681,0.973),(682,0.973),(683,0.974),(684,0.964),(685,0.945),(686,0.927),(687,0.908),(688,0.871),(689,0.822),(690,0.773),(691,0.687),(692,0.594),(693,0.505),(694,0.433),(695,0.361),(696,0.289),(697,0.223),(698,0.188),(699,0.152),(700,0.116),(701,0.106),(702,0.095),(703,0.084),(704,0.074),(705,0.063),(706,0.057),(707,0.054),(708,0.051),(709,0.048),(710,0.045),(711,0.042),(712,0.039),(713,0.036),(714,0.033),(715,0.03),(716,0.027),(717,0.024),(718,0.022),(719,0.021),(720,0.02),(721,0.018),(722,0.017),(723,0.015),(724,0.014),(725,0.012),(726,0.011),(727,0.01),(728,0.009),(729,0.007),(730,0.006),(731,0.006),(732,0.005),(733,0.005),(734,0.005),(735,0.005),(736,0.004),(737,0.004),(738,0.004),(739,0.003),(740,0.003),(741,0.003),(742,0.002),(743,0.002),(744,0.002),(745,0.002),(746,0.001)];responses['NIR'] = [(727,0.001),(728,0.001),(729,0.002),(730,0.002),(731,0.003),(732,0.003),(733,0.004),(734,0.004),(735,0.005),(736,0.005),(737,0.006),(738,0.006),(739,0.007),(740,0.007),(741,0.008),(742,0.008),(743,0.009),(744,0.009),(745,0.01),(746,0.012),(747,0.014),(748,0.016),(749,0.018),(750,0.02),(751,0.022),(752,0.025),(753,0.028),(754,0.031),(755,0.034),(756,0.042),(757,0.05),(758,0.058),(759,0.066),(760,0.074),(761,0.083),(762,0.09),(763,0.099),(764,0.121),(765,0.143),(766,0.165),(767,0.187),(768,0.216),(769,0.251),(770,0.286),(771,0.322),(772,0.357),(773,0.393),(774,0.428),(775,0.464),(776,0.5),(777,0.544),(778,0.587),(779,0.63),(780,0.673),(781,0.717),(782,0.76),(783,0.795),(784,0.822),(785,0.849),(786,0.876),(787,0.902),(788,0.917),(789,0.932),(790,0.946),(791,0.956),(792,0.963),(793,0.97),(794,0.976),(795,0.983),(796,0.986),(797,0.99),(798,0.993),(799,0.997),(800,1.0),(801,0.997),(802,0.994),(803,0.992),(804,0.989),(805,0.986),(806,0.983),(807,0.98),(808,0.977),(809,0.974),(810,0.971),(811,0.968),(812,0.965),(813,0.962),(814,0.959),(815,0.956),(816,0.953),(817,0.95),(818,0.947),(819,0.945),(820,0.942),(821,0.939),(822,0.936),(823,0.933),(824,0.93),(825,0.93),(826,0.932),(827,0.934),(828,0.936),(829,0.938),(830,0.94),(831,0.942),(832,0.944),(833,0.946),(834,0.948),(835,0.95),(836,0.952),(837,0.954),(838,0.956),(839,0.958),(840,0.96),(841,0.962),(842,0.964),(843,0.966),(844,0.968),(845,0.97),(846,0.972),(847,0.974),(848,0.976),(849,0.978),(850,0.98),(851,0.978),(852,0.977),(853,0.975),(854,0.974),(855,0.973),(856,0.971),(857,0.97),(858,0.967),(859,0.965),(860,0.963),(861,0.96),(862,0.959),(863,0.959),(864,0.959),(865,0.96),(866,0.961),(867,0.962),(868,0.963),(869,0.964),(870,0.965),(871,0.967),(872,0.968),(873,0.965),(874,0.963),(875,0.96),(876,0.955),(877,0.95),(878,0.945),(879,0.94),(880,0.935),(881,0.929),(882,0.922),(883,0.915),(884,0.908),(885,0.901),(886,0.894),(887,0.887),(888,0.88),(889,0.873),(890,0.866),(891,0.865),(892,0.864),(893,0.858),(894,0.846),(895,0.834),(896,0.823),(897,0.811),(898,0.8),(899,0.789),(900,0.779),(901,0.733),(902,0.688),(903,0.643),(904,0.578),(905,0.509),(906,0.44),(907,0.371),(908,0.321),(909,0.275),(910,0.23),(911,0.185),(912,0.156),(913,0.13),(914,0.105),(915,0.084),(916,0.074),(917,0.064),(918,0.054),(919,0.044),(920,0.034),(921,0.031),(922,0.027),(923,0.024),(924,0.02),(925,0.017),(926,0.015),(927,0.013),(928,0.012),(929,0.01),(930,0.008),(931,0.008),(932,0.007),(933,0.007),(934,0.006),(935,0.006),(936,0.005),(937,0.005),(938,0.005),(939,0.004),(940,0.004),(941,0.003),(942,0.003),(943,0.002),(944,0.002),(945,0.002),(946,0.001)];responses['SWIR-1'] = [(1512,0.001),(1513,0.001),(1514,0.001),(1515,0.001),(1516,0.001),(1517,0.001),(1518,0.002),(1519,0.002),(1520,0.002),(1521,0.002),(1522,0.003),(1523,0.004),(1524,0.004),(1525,0.005),(1526,0.006),(1527,0.007),(1528,0.007),(1529,0.008),(1530,0.009),(1531,0.01),(1532,0.012),(1533,0.013),(1534,0.015),(1535,0.016),(1536,0.018),(1537,0.019),(1538,0.021),(1539,0.022),(1540,0.024),(1541,0.028),(1542,0.033),(1543,0.038),(1544,0.043),(1545,0.048),(1546,0.057),(1547,0.067),(1548,0.077),(1549,0.087),(1550,0.098),(1551,0.114),(1552,0.132),(1553,0.151),(1554,0.17),(1555,0.189),(1556,0.208),(1557,0.228),(1558,0.247),(1559,0.267),(1560,0.287),(1561,0.312),(1562,0.34),(1563,0.368),(1564,0.396),(1565,0.425),(1566,0.454),(1567,0.483),(1568,0.512),(1569,0.541),(1570,0.571),(1571,0.598),(1572,0.625),(1573,0.653),(1574,0.68),(1575,0.708),(1576,0.732),(1577,0.755),(1578,0.777),(1579,0.8),(1580,0.824),(1581,0.842),(1582,0.858),(1583,0.874),(1584,0.89),(1585,0.907),(1586,0.916),(1587,0.924),(1588,0.93),(1589,0.934),(1590,0.939),(1591,0.943),(1592,0.947),(1593,0.946),(1594,0.943),(1595,0.94),(1596,0.937),(1597,0.934),(1598,0.933),(1599,0.933),(1600,0.933),(1601,0.931),(1602,0.929),(1603,0.928),(1604,0.928),(1605,0.928),(1606,0.928),(1607,0.928),(1608,0.928),(1609,0.933),(1610,0.94),(1611,0.944),(1612,0.947),(1613,0.949),(1614,0.952),(1615,0.955),(1616,0.958),(1617,0.961),(1618,0.963),(1619,0.966),(1620,0.969),(1621,0.972),(1622,0.975),(1623,0.978),(1624,0.98),(1625,0.983),(1626,0.985),(1627,0.988),(1628,0.989),(1629,0.989),(1630,0.988),(1631,0.987),(1632,0.986),(1633,0.985),(1634,0.984),(1635,0.983),(1636,0.981),(1637,0.98),(1638,0.979),(1639,0.978),(1640,0.977),(1641,0.976),(1642,0.975),(1643,0.974),(1644,0.973),(1645,0.972),(1646,0.971),(1647,0.97),(1648,0.969),(1649,0.969),(1650,0.968),(1651,0.967),(1652,0.967),(1653,0.968),(1654,0.97),(1655,0.971),(1656,0.973),(1657,0.975),(1658,0.977),(1659,0.979),(1660,0.98),(1661,0.982),(1662,0.983),(1663,0.985),(1664,0.986),(1665,0.988),(1666,0.988),(1667,0.987),(1668,0.986),(1669,0.985),(1670,0.984),(1671,0.984),(1672,0.983),(1673,0.983),(1674,0.982),(1675,0.982),(1676,0.981),(1677,0.981),(1678,0.98),(1679,0.98),(1680,0.979),(1681,0.979),(1682,0.978),(1683,0.978),(1684,0.977),(1685,0.977),(1686,0.976),(1687,0.976),(1688,0.975),(1689,0.975),(1690,0.974),(1691,0.975),(1692,0.977),(1693,0.978),(1694,0.98),(1695,0.982),(1696,0.983),(1697,0.985),(1698,0.987),(1699,0.988),(1700,0.99),(1701,0.99),(1702,0.991),(1703,0.992),(1704,0.993),(1705,0.993),(1706,0.994),(1707,0.995),(1708,0.995),(1709,0.996),(1710,0.997),(1711,0.998),(1712,0.998),(1713,0.999),(1714,0.999),(1715,1.0),(1716,0.999),(1717,0.998),(1718,0.996),(1719,0.995),(1720,0.993),(1721,0.992),(1722,0.99),(1723,0.988),(1724,0.986),(1725,0.974),(1726,0.982),(1727,0.98),(1728,0.978),(1729,0.976),(1730,0.975),(1731,0.973),(1732,0.971),(1733,0.969),(1734,0.967),(1735,0.965),(1736,0.963),(1737,0.961),(1738,0.96),(1739,0.958),(1740,0.956),(1741,0.955),(1742,0.954),(1743,0.953),(1744,0.953),(1745,0.952),(1746,0.951),(1747,0.95),(1748,0.95),(1749,0.949),(1750,0.948),(1751,0.951),(1752,0.954),(1753,0.957),(1754,0.961),(1755,0.964),(1756,0.965),(1757,0.964),(1758,0.962),(1759,0.961),(1760,0.96),(1761,0.957),(1762,0.953),(1763,0.948),(1764,0.944),(1765,0.94),(1766,0.931),(1767,0.92),(1768,0.909),(1769,0.898),(1770,0.887),(1771,0.868),(1772,0.846),(1773,0.823),(1774,0.801),(1775,0.779),(1776,0.752),(1777,0.723),(1778,0.695),(1779,0.666),(1780,0.637),(1781,0.607),(1782,0.577),(1783,0.547),(1784,0.516),(1785,0.486),(1786,0.456),(1787,0.425),(1788,0.395),(1789,0.365),(1790,0.334),(1791,0.313),(1792,0.296),(1793,0.279),(1794,0.262),(1795,0.245),(1796,0.228),(1797,0.211),(1798,0.194),(1799,0.177),(1800,0.16),(1801,0.149),(1802,0.141),(1803,0.133),(1804,0.125),(1805,0.117),(1806,0.109),(1807,0.101),(1808,0.093),(1809,0.085),(1810,0.077),(1811,0.072),(1812,0.069),(1813,0.066),(1814,0.063),(1815,0.06),(1816,0.057),(1817,0.054),(1818,0.051),(1819,0.048),(1820,0.045),(1821,0.042),(1822,0.04),(1823,0.038),(1824,0.036),(1825,0.033),(1826,0.031),(1827,0.029),(1828,0.027),(1829,0.025),(1830,0.022),(1831,0.021),(1832,0.021),(1833,0.02),(1834,0.02),(1835,0.019),(1836,0.019),(1837,0.018),(1838,0.018),(1839,0.017),(1840,0.016),(1841,0.016),(1842,0.015),(1843,0.015),(1844,0.014),(1845,0.014),(1846,0.013),(1847,0.013),(1848,0.012),(1849,0.012),(1850,0.011),(1851,0.01),(1852,0.01),(1853,0.01),(1854,0.009),(1855,0.009),(1856,0.009),(1857,0.008),(1858,0.008),(1859,0.008),(1860,0.007),(1861,0.007),(1862,0.007),(1863,0.006),(1864,0.006),(1865,0.005),(1866,0.005),(1867,0.005),(1868,0.004),(1869,0.004),(1870,0.004),(1871,0.003),(1872,0.003),(1873,0.003),(1874,0.002),(1875,0.002),(1876,0.002),(1877,0.001)];responses['SWIR-2'] = [(1956,0.001),(1957,0.001),(1958,0.001),(1959,0.002),(1960,0.002),(1961,0.002),(1962,0.002),(1963,0.002),(1964,0.002),(1965,0.003),(1966,0.003),(1967,0.003),(1968,0.003),(1969,0.003),(1970,0.004),(1971,0.004),(1972,0.004),(1973,0.004),(1974,0.004),(1975,0.004),(1976,0.005),(1977,0.005),(1978,0.005),(1979,0.005),(1980,0.005),(1981,0.006),(1982,0.006),(1983,0.006),(1984,0.006),(1985,0.006),(1986,0.007),(1987,0.007),(1988,0.007),(1989,0.007),(1990,0.007),(1991,0.008),(1992,0.008),(1993,0.008),(1994,0.008),(1995,0.008),(1996,0.009),(1997,0.009),(1998,0.009),(1999,0.009),(2000,0.009),(2001,0.01),(2002,0.01),(2003,0.011),(2004,0.011),(2005,0.012),(2006,0.012),(2007,0.013),(2008,0.013),(2009,0.014),(2010,0.014),(2011,0.015),(2012,0.015),(2013,0.016),(2014,0.016),(2015,0.017),(2016,0.017),(2017,0.018),(2018,0.018),(2019,0.019),(2020,0.019),(2021,0.021),(2022,0.023),(2023,0.024),(2024,0.026),(2025,0.027),(2026,0.029),(2027,0.031),(2028,0.032),(2029,0.034),(2030,0.036),(2031,0.037),(2032,0.039),(2033,0.041),(2034,0.042),(2035,0.044),(2036,0.046),(2037,0.047),(2038,0.049),(2039,0.051),(2040,0.052),(2041,0.054),(2042,0.056),(2043,0.057),(2044,0.059),(2045,0.061),(2046,0.062),(2047,0.064),(2048,0.066),(2049,0.068),(2050,0.069),(2051,0.072),(2052,0.075),(2053,0.078),(2054,0.081),(2055,0.084),(2056,0.087),(2057,0.09),(2058,0.093),(2059,0.096),(2060,0.1),(2061,0.105),(2062,0.109),(2063,0.115),(2064,0.12),(2065,0.125),(2066,0.13),(2067,0.135),(2068,0.14),(2069,0.145),(2070,0.15),(2071,0.16),(2072,0.17),(2073,0.18),(2074,0.19),(2075,0.2),(2076,0.211),(2077,0.221),(2078,0.231),(2079,0.241),(2080,0.251),(2081,0.265),(2082,0.28),(2083,0.294),(2084,0.308),(2085,0.323),(2086,0.337),(2087,0.352),(2088,0.366),(2089,0.38),(2090,0.395),(2091,0.409),(2092,0.424),(2093,0.438),(2094,0.453),(2095,0.467),(2096,0.482),(2097,0.496),(2098,0.511),(2099,0.526),(2100,0.54),(2101,0.556),(2102,0.571),(2103,0.586),(2104,0.602),(2105,0.617),(2106,0.633),(2107,0.648),(2108,0.664),(2109,0.679),(2110,0.695),(2111,0.71),(2112,0.726),(2113,0.742),(2114,0.758),(2115,0.773),(2116,0.789),(2117,0.805),(2118,0.821),(2119,0.837),(2120,0.853),(2121,0.864),(2122,0.876),(2123,0.887),(2124,0.898),(2125,0.91),(2126,0.915),(2127,0.92),(2128,0.925),(2129,0.931),(2130,0.936),(2131,0.939),(2132,0.941),(2133,0.944),(2134,0.947),(2135,0.95),(2136,0.95),(2137,0.95),(2138,0.95),(2139,0.95),(2140,0.951),(2141,0.95),(2142,0.95),(2143,0.95),(2144,0.949),(2145,0.949),(2146,0.946),(2147,0.944),(2148,0.941),(2149,0.938),(2150,0.936),(2151,0.937),(2152,0.939),(2153,0.941),(2154,0.942),(2155,0.944),(2156,0.944),(2157,0.945),(2158,0.945),(2159,0.946),(2160,0.946),(2161,0.947),(2162,0.947),(2163,0.947),(2164,0.948),(2165,0.948),(2166,0.951),(2167,0.953),(2168,0.956),(2169,0.959),(2170,0.962),(2171,0.965),(2172,0.967),(2173,0.97),(2174,0.973),(2175,0.976),(2176,0.979),(2177,0.982),(2178,0.985),(2179,0.988),(2180,0.991),(2181,0.994),(2182,0.996),(2183,0.997),(2184,0.997),(2185,0.998),(2186,0.998),(2187,0.998),(2188,0.999),(2189,0.999),(2190,0.999),(2191,1.0),(2192,1.0),(2193,0.999),(2194,0.999),(2195,0.998),(2196,0.998),(2197,0.997),(2198,0.997),(2199,0.996),(2200,0.995),(2201,0.995),(2202,0.995),(2203,0.995),(2204,0.994),(2205,0.994),(2206,0.994),(2207,0.993),(2208,0.993),(2209,0.993),(2210,0.993),(2211,0.992),(2212,0.992),(2213,0.992),(2214,0.991),(2215,0.991),(2216,0.991),(2217,0.99),(2218,0.99),(2219,0.99),(2220,0.989),(2221,0.989),(2222,0.989),(2223,0.988),(2224,0.988),(2225,0.987),(2226,0.981),(2227,0.975),(2228,0.969),(2229,0.962),(2230,0.956),(2231,0.955),(2232,0.953),(2233,0.952),(2234,0.95),(2235,0.949),(2236,0.947),(2237,0.946),(2238,0.945),(2239,0.943),(2240,0.942),(2241,0.94),(2242,0.938),(2243,0.936),(2244,0.934),(2245,0.932),(2246,0.93),(2247,0.928),(2248,0.926),(2249,0.924),(2250,0.922),(2251,0.922),(2252,0.921),(2253,0.92),(2254,0.92),(2255,0.919),(2256,0.919),(2257,0.918),(2258,0.917),(2259,0.917),(2260,0.916),(2261,0.915),(2262,0.914),(2263,0.914),(2264,0.913),(2265,0.912),(2266,0.911),(2267,0.91),(2268,0.909),(2269,0.908),(2270,0.906),(2271,0.905),(2272,0.903),(2273,0.901),(2274,0.9),(2275,0.898),(2276,0.896),(2277,0.895),(2278,0.893),(2279,0.892),(2280,0.89),(2281,0.883),(2282,0.876),(2283,0.87),(2284,0.863),(2285,0.856),(2286,0.849),(2287,0.842),(2288,0.836),(2289,0.829),(2290,0.822),(2291,0.816),(2292,0.809),(2293,0.803),(2294,0.796),(2295,0.79),(2296,0.783),(2297,0.777),(2298,0.77),(2299,0.764),(2300,0.757),(2301,0.751),(2302,0.746),(2303,0.74),(2304,0.734),(2305,0.728),(2306,0.728),(2307,0.728),(2308,0.734),(2309,0.741),(2310,0.747),(2311,0.754),(2312,0.76),(2313,0.766),(2314,0.772),(2315,0.778),(2316,0.784),(2317,0.79),(2318,0.793),(2319,0.802),(2320,0.808),(2321,0.819),(2322,0.83),(2323,0.841),(2324,0.852),(2325,0.857),(2326,0.863),(2327,0.868),(2328,0.874),(2329,0.874),(2330,0.874),(2331,0.874),(2332,0.875),(2333,0.868),(2334,0.861),(2335,0.854),(2336,0.836),(2337,0.819),(2338,0.801),(2339,0.748),(2340,0.695),(2341,0.669),(2342,0.642),(2343,0.616),(2344,0.59),(2345,0.564),(2346,0.537),(2347,0.511),(2348,0.484),(2349,0.458),(2350,0.431),(2351,0.409),(2352,0.386),(2353,0.364),(2354,0.342),(2355,0.319),(2356,0.296),(2357,0.274),(2358,0.251),(2359,0.229),(2360,0.206),(2361,0.193),(2362,0.18),(2363,0.167),(2364,0.154),(2365,0.141),(2366,0.128),(2367,0.115),(2368,0.102),(2369,0.089),(2370,0.076),(2371,0.072),(2372,0.068),(2373,0.063),(2374,0.059),(2375,0.055),(2376,0.05),(2377,0.046),(2378,0.042),(2379,0.037),(2380,0.033),(2381,0.031),(2382,0.029),(2383,0.026),(2384,0.024),(2385,0.022),(2386,0.02),(2387,0.018),(2388,0.015),(2389,0.013),(2390,0.011),(2391,0.01),(2392,0.01),(2393,0.009),(2394,0.009),(2395,0.008),(2396,0.008),(2397,0.007),(2398,0.007),(2399,0.006),(2400,0.005),(2401,0.005),(2402,0.004),(2403,0.004),(2404,0.003),(2405,0.003),(2406,0.002),(2407,0.002),(2408,0.001)]",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToLandsat45Tm\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToLandsat7Etm",
    "label": "Spectral resampling (to Landsat 7 ETM+)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the Landsat missions website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat7Etm",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat7Etm",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();responses['Blue'] = [(435,0.016),(436,0.027),(437,0.048),(438,0.094),(439,0.167),(440,0.287),(441,0.459),(442,0.605),(443,0.728),(444,0.769),(445,0.792),(446,0.821),(447,0.857),(448,0.857),(449,0.862),(450,0.839),(451,0.845),(452,0.81),(453,0.802),(454,0.804),(455,0.779),(456,0.798),(457,0.816),(458,0.876),(459,0.888),(460,0.901),(461,0.918),(462,0.896),(463,0.903),(464,0.888),(465,0.89),(466,0.863),(467,0.86),(468,0.842),(469,0.866),(470,0.875),(471,0.881),(472,0.888),(473,0.898),(474,0.879),(475,0.884),(476,0.907),(477,0.928),(478,0.932),(479,0.955),(480,0.958),(481,0.948),(482,0.952),(483,0.956),(484,0.98),(485,0.98),(486,0.975),(487,0.973),(488,0.977),(489,0.958),(490,0.965),(491,0.957),(492,0.952),(493,0.973),(494,0.974),(495,0.995),(496,0.986),(497,0.986),(498,0.994),(499,1.0),(500,0.99),(501,0.99),(502,0.976),(503,0.983),(504,0.976),(505,0.983),(506,0.96),(507,0.973),(508,0.964),(509,0.975),(510,0.96),(511,0.932),(512,0.853),(513,0.684),(514,0.486),(515,0.293),(516,0.15),(517,0.073),(518,0.036),(519,0.019),(520,0.009)];responses['Green'] = [(502,0.001),(503,0.002),(504,0.002),(505,0.003),(506,0.005),(507,0.009),(508,0.014),(509,0.024),(510,0.026),(511,0.041),(512,0.06),(513,0.088),(514,0.126),(515,0.174),(516,0.236),(517,0.308),(518,0.388),(519,0.472),(520,0.552),(521,0.621),(522,0.676),(523,0.716),(524,0.743),(525,0.759),(526,0.769),(527,0.779),(528,0.79),(529,0.805),(530,0.822),(531,0.842),(532,0.861),(533,0.878),(534,0.893),(535,0.905),(536,0.916),(537,0.924),(538,0.933),(539,0.942),(540,0.947),(541,0.951),(542,0.953),(543,0.952),(544,0.951),(545,0.952),(546,0.951),(547,0.951),(548,0.952),(549,0.952),(550,0.953),(551,0.951),(552,0.95),(553,0.95),(554,0.951),(555,0.954),(556,0.96),(557,0.966),(558,0.968),(559,0.965),(560,0.959),(561,0.951),(562,0.944),(563,0.937),(564,0.932),(565,0.933),(566,0.935),(567,0.937),(568,0.94),(569,0.945),(570,0.951),(571,0.955),(572,0.957),(573,0.956),(574,0.957),(575,0.955),(576,0.952),(577,0.954),(578,0.958),(579,0.963),(580,0.973),(581,0.981),(582,0.988),(583,0.995),(584,1.0),(585,1.0),(586,0.994),(587,0.983),(588,0.969),(589,0.954),(590,0.942),(591,0.936),(592,0.932),(593,0.928),(594,0.924),(595,0.912),(596,0.883),(597,0.834),(598,0.763),(599,0.674),(600,0.574),(601,0.473),(602,0.38),(603,0.3),(604,0.235),(605,0.185),(606,0.146),(607,0.117),(608,0.094),(609,0.077),(610,0.062),(611,0.052),(612,0.042),(613,0.033),(614,0.026),(615,0.021),(616,0.016),(617,0.012),(618,0.009),(619,0.007),(620,0.005),(621,0.004),(622,0.003),(623,0.002),(624,0.001)];responses['Red'] = [(619,0.001),(620,0.002),(621,0.003),(622,0.006),(623,0.013),(624,0.025),(625,0.047),(626,0.083),(627,0.137),(628,0.211),(629,0.306),(630,0.419),(631,0.545),(632,0.674),(633,0.788),(634,0.873),(635,0.921),(636,0.941),(637,0.943),(638,0.942),(639,0.939),(640,0.937),(641,0.935),(642,0.935),(643,0.938),(644,0.943),(645,0.949),(646,0.953),(647,0.961),(648,0.968),(649,0.971),(650,0.973),(651,0.974),(652,0.972),(653,0.969),(654,0.963),(655,0.958),(656,0.956),(657,0.955),(658,0.955),(659,0.956),(660,0.962),(661,0.969),(662,0.977),(663,0.983),(664,0.988),(665,0.993),(666,0.996),(667,0.997),(668,0.999),(669,1.0),(670,1.0),(671,0.998),(672,0.996),(673,0.995),(674,0.993),(675,0.992),(676,0.991),(677,0.989),(678,0.988),(679,0.984),(680,0.977),(681,0.97),(682,0.96),(683,0.949),(684,0.94),(685,0.932),(686,0.919),(687,0.898),(688,0.863),(689,0.809),(690,0.729),(691,0.625),(692,0.506),(693,0.382),(694,0.272),(695,0.183),(696,0.12),(697,0.079),(698,0.053),(699,0.036),(700,0.025),(701,0.02),(702,0.014),(703,0.01),(704,0.007)];responses['NIR'] = [(741,0.001),(742,0.002),(743,0.002),(744,0.003),(745,0.004),(746,0.003),(747,0.003),(748,0.002),(749,0.002),(750,0.001),(751,0.014),(752,0.018),(753,0.022),(754,0.027),(755,0.032),(756,0.038),(757,0.047),(758,0.056),(759,0.069),(760,0.069),(761,0.083),(762,0.099),(763,0.121),(764,0.146),(765,0.175),(766,0.209),(767,0.248),(768,0.294),(769,0.346),(770,0.402),(771,0.463),(772,0.523),(773,0.588),(774,0.649),(775,0.705),(776,0.757),(777,0.797),(778,0.827),(779,0.853),(780,0.871),(781,0.884),(782,0.892),(783,0.899),(784,0.903),(785,0.908),(786,0.911),(787,0.916),(788,0.92),(789,0.925),(790,0.926),(791,0.927),(792,0.927),(793,0.929),(794,0.932),(795,0.93),(796,0.926),(797,0.926),(798,0.925),(799,0.928),(800,0.925),(801,0.926),(802,0.928),(803,0.928),(804,0.928),(805,0.923),(806,0.92),(807,0.919),(808,0.914),(809,0.91),(810,0.908),(811,0.905),(812,0.903),(813,0.904),(814,0.902),(815,0.909),(816,0.917),(817,0.92),(818,0.928),(819,0.938),(820,0.946),(821,0.953),(822,0.962),(823,0.969),(824,0.971),(825,0.971),(826,0.97),(827,0.969),(828,0.969),(829,0.97),(830,0.967),(831,0.969),(832,0.968),(833,0.963),(834,0.965),(835,0.967),(836,0.965),(837,0.963),(838,0.958),(839,0.95),(840,0.949),(841,0.943),(842,0.933),(843,0.929),(844,0.928),(845,0.925),(846,0.924),(847,0.927),(848,0.932),(849,0.934),(850,0.943),(851,0.952),(852,0.956),(853,0.966),(854,0.977),(855,0.985),(856,0.99),(857,0.992),(858,0.993),(859,0.994),(860,0.998),(861,0.996),(862,0.992),(863,0.991),(864,0.992),(865,0.994),(866,0.993),(867,0.997),(868,0.997),(869,0.996),(870,0.998),(871,0.999),(872,1.0),(873,0.999),(874,0.996),(875,0.991),(876,0.99),(877,0.991),(878,0.985),(879,0.978),(880,0.969),(881,0.955),(882,0.937),(883,0.916),(884,0.892),(885,0.868),(886,0.845),(887,0.824),(888,0.811),(889,0.807),(890,0.819),(891,0.841),(892,0.868),(893,0.892),(894,0.892),(895,0.854),(896,0.77),(897,0.644),(898,0.501),(899,0.365),(900,0.256),(901,0.177),(902,0.122),(903,0.085),(904,0.061),(905,0.044),(906,0.032),(907,0.025),(908,0.019),(909,0.014),(910,0.011),(911,0.011),(912,0.008),(913,0.006),(914,0.005)];responses['SWIR-1'] = [(1508,0.001),(1509,0.001),(1510,0.001),(1511,0.007),(1512,0.013),(1513,0.01),(1514,0.006),(1515,0.012),(1516,0.008),(1517,0.003),(1518,0.009),(1519,0.015),(1520,0.013),(1521,0.012),(1522,0.018),(1523,0.024),(1524,0.032),(1525,0.04),(1526,0.041),(1527,0.049),(1528,0.057),(1529,0.067),(1530,0.076),(1531,0.087),(1532,0.097),(1533,0.109),(1534,0.12),(1535,0.148),(1536,0.176),(1537,0.196),(1538,0.215),(1539,0.244),(1540,0.274),(1541,0.306),(1542,0.339),(1543,0.393),(1544,0.428),(1545,0.462),(1546,0.481),(1547,0.499),(1548,0.529),(1549,0.558),(1550,0.578),(1551,0.598),(1552,0.616),(1553,0.634),(1554,0.65),(1555,0.667),(1556,0.686),(1557,0.704),(1558,0.714),(1559,0.724),(1560,0.737),(1561,0.75),(1562,0.764),(1563,0.778),(1564,0.793),(1565,0.808),(1566,0.817),(1567,0.825),(1568,0.838),(1569,0.851),(1570,0.859),(1571,0.867),(1572,0.872),(1573,0.878),(1574,0.884),(1575,0.893),(1576,0.902),(1577,0.901),(1578,0.901),(1579,0.899),(1580,0.896),(1581,0.896),(1582,0.897),(1583,0.893),(1584,0.89),(1585,0.895),(1586,0.899),(1587,0.891),(1588,0.884),(1589,0.88),(1590,0.876),(1591,0.872),(1592,0.867),(1593,0.87),(1594,0.873),(1595,0.873),(1596,0.872),(1597,0.875),(1598,0.879),(1599,0.877),(1600,0.874),(1601,0.868),(1602,0.861),(1603,0.86),(1604,0.859),(1605,0.868),(1606,0.877),(1607,0.878),(1608,0.879),(1609,0.889),(1610,0.899),(1611,0.897),(1612,0.895),(1613,0.893),(1614,0.896),(1615,0.9),(1616,0.898),(1617,0.897),(1618,0.907),(1619,0.917),(1620,0.919),(1621,0.921),(1622,0.924),(1623,0.926),(1624,0.928),(1625,0.929),(1626,0.937),(1627,0.945),(1628,0.946),(1629,0.947),(1630,0.947),(1631,0.948),(1632,0.951),(1633,0.955),(1634,0.954),(1635,0.952),(1636,0.961),(1637,0.969),(1638,0.964),(1639,0.96),(1640,0.961),(1641,0.962),(1642,0.961),(1643,0.959),(1644,0.969),(1645,0.978),(1646,0.969),(1647,0.96),(1648,0.957),(1649,0.955),(1650,0.954),(1651,0.952),(1652,0.951),(1653,0.951),(1654,0.951),(1655,0.952),(1656,0.952),(1657,0.954),(1658,0.956),(1659,0.95),(1660,0.944),(1661,0.939),(1662,0.935),(1663,0.934),(1664,0.933),(1665,0.931),(1666,0.928),(1667,0.935),(1668,0.942),(1669,0.945),(1670,0.948),(1671,0.945),(1672,0.942),(1673,0.938),(1674,0.933),(1675,0.939),(1676,0.944),(1677,0.946),(1678,0.948),(1679,0.947),(1680,0.945),(1681,0.944),(1682,0.943),(1683,0.947),(1684,0.951),(1685,0.955),(1686,0.96),(1687,0.964),(1688,0.965),(1689,0.967),(1690,0.969),(1691,0.971),(1692,0.972),(1693,0.974),(1694,0.982),(1695,0.991),(1696,0.993),(1697,0.995),(1698,0.997),(1699,0.999),(1700,0.998),(1701,0.996),(1702,0.995),(1703,0.994),(1704,0.997),(1705,1.0),(1706,0.997),(1707,0.994),(1708,0.988),(1709,0.983),(1710,0.987),(1711,0.99),(1712,0.989),(1713,0.988),(1714,0.987),(1715,0.989),(1716,0.992),(1717,0.989),(1718,0.986),(1719,0.984),(1720,0.981),(1721,0.982),(1722,0.983),(1723,0.979),(1724,0.976),(1725,0.978),(1726,0.97),(1727,0.969),(1728,0.968),(1729,0.964),(1730,0.96),(1731,0.952),(1732,0.944),(1733,0.933),(1734,0.921),(1735,0.902),(1736,0.883),(1737,0.864),(1738,0.845),(1739,0.818),(1740,0.791),(1741,0.751),(1742,0.711),(1743,0.674),(1744,0.638),(1745,0.608),(1746,0.577),(1747,0.547),(1748,0.505),(1749,0.462),(1750,0.428),(1751,0.393),(1752,0.359),(1753,0.325),(1754,0.296),(1755,0.267),(1756,0.239),(1757,0.212),(1758,0.193),(1759,0.175),(1760,0.159),(1761,0.142),(1762,0.127),(1763,0.111),(1764,0.097),(1765,0.084),(1766,0.08),(1767,0.077),(1768,0.067),(1769,0.058),(1770,0.053),(1771,0.049),(1772,0.045),(1773,0.042),(1774,0.041),(1775,0.039),(1776,0.036),(1777,0.034),(1778,0.027),(1779,0.02),(1780,0.021),(1781,0.021),(1782,0.021),(1783,0.022),(1784,0.016),(1785,0.011),(1786,0.012),(1787,0.012),(1788,0.008),(1789,0.004),(1790,0.006),(1791,0.008),(1792,0.004)];responses['SWIR-2'] = [(2015,0.002),(2016,0.002),(2017,0.002),(2018,0.002),(2019,0.007),(2020,0.012),(2021,0.01),(2022,0.009),(2023,0.008),(2024,0.007),(2025,0.009),(2026,0.011),(2027,0.015),(2028,0.02),(2029,0.019),(2030,0.017),(2031,0.023),(2032,0.03),(2033,0.032),(2034,0.035),(2035,0.037),(2036,0.041),(2037,0.044),(2038,0.047),(2039,0.051),(2040,0.058),(2041,0.065),(2042,0.072),(2043,0.08),(2044,0.084),(2045,0.088),(2046,0.095),(2047,0.102),(2048,0.117),(2049,0.133),(2050,0.149),(2051,0.165),(2052,0.188),(2053,0.204),(2054,0.22),(2055,0.242),(2056,0.264),(2057,0.29),(2058,0.316),(2059,0.342),(2060,0.367),(2061,0.394),(2062,0.421),(2063,0.452),(2064,0.484),(2065,0.519),(2066,0.554),(2067,0.59),(2068,0.63),(2069,0.67),(2070,0.677),(2071,0.683),(2072,0.707),(2073,0.73),(2074,0.743),(2075,0.756),(2076,0.762),(2077,0.767),(2078,0.781),(2079,0.794),(2080,0.784),(2081,0.774),(2082,0.775),(2083,0.776),(2084,0.783),(2085,0.789),(2086,0.775),(2087,0.78),(2088,0.784),(2089,0.781),(2090,0.778),(2091,0.773),(2092,0.768),(2093,0.765),(2094,0.762),(2095,0.762),(2096,0.761),(2097,0.766),(2098,0.77),(2099,0.775),(2100,0.775),(2101,0.77),(2102,0.764),(2103,0.774),(2104,0.784),(2105,0.788),(2106,0.792),(2107,0.803),(2108,0.814),(2109,0.804),(2110,0.794),(2111,0.809),(2112,0.825),(2113,0.821),(2114,0.817),(2115,0.811),(2116,0.806),(2117,0.819),(2118,0.82),(2119,0.821),(2120,0.836),(2121,0.852),(2122,0.842),(2123,0.832),(2124,0.834),(2125,0.836),(2126,0.843),(2127,0.85),(2128,0.853),(2129,0.855),(2130,0.859),(2131,0.862),(2132,0.857),(2133,0.853),(2134,0.862),(2135,0.871),(2136,0.848),(2137,0.865),(2138,0.882),(2139,0.878),(2140,0.875),(2141,0.868),(2142,0.86),(2143,0.858),(2144,0.856),(2145,0.872),(2146,0.887),(2147,0.868),(2148,0.85),(2149,0.861),(2150,0.872),(2151,0.879),(2152,0.868),(2153,0.857),(2154,0.861),(2155,0.865),(2156,0.866),(2157,0.867),(2158,0.869),(2159,0.871),(2160,0.877),(2161,0.882),(2162,0.876),(2163,0.87),(2164,0.87),(2165,0.869),(2166,0.873),(2167,0.875),(2168,0.877),(2169,0.872),(2170,0.868),(2171,0.874),(2172,0.88),(2173,0.878),(2174,0.877),(2175,0.873),(2176,0.87),(2177,0.874),(2178,0.878),(2179,0.879),(2180,0.88),(2181,0.874),(2182,0.868),(2183,0.881),(2184,0.875),(2185,0.87),(2186,0.863),(2187,0.856),(2188,0.859),(2189,0.863),(2190,0.863),(2191,0.863),(2192,0.86),(2193,0.857),(2194,0.85),(2195,0.844),(2196,0.852),(2197,0.859),(2198,0.858),(2199,0.857),(2200,0.854),(2201,0.852),(2202,0.859),(2203,0.866),(2204,0.867),(2205,0.868),(2206,0.862),(2207,0.856),(2208,0.856),(2209,0.856),(2210,0.847),(2211,0.854),(2212,0.861),(2213,0.862),(2214,0.862),(2215,0.851),(2216,0.84),(2217,0.848),(2218,0.856),(2219,0.847),(2220,0.838),(2221,0.847),(2222,0.856),(2223,0.837),(2224,0.839),(2225,0.84),(2226,0.842),(2227,0.826),(2228,0.835),(2229,0.844),(2230,0.836),(2231,0.827),(2232,0.835),(2233,0.842),(2234,0.832),(2235,0.822),(2236,0.832),(2237,0.843),(2238,0.833),(2239,0.823),(2240,0.839),(2241,0.854),(2242,0.839),(2243,0.846),(2244,0.853),(2245,0.854),(2246,0.854),(2247,0.859),(2248,0.865),(2249,0.869),(2250,0.873),(2251,0.871),(2252,0.869),(2253,0.867),(2254,0.865),(2255,0.879),(2256,0.893),(2257,0.891),(2258,0.89),(2259,0.89),(2260,0.898),(2261,0.906),(2262,0.915),(2263,0.924),(2264,0.922),(2265,0.92),(2266,0.921),(2267,0.922),(2268,0.931),(2269,0.939),(2270,0.928),(2271,0.916),(2272,0.928),(2273,0.94),(2274,0.93),(2275,0.936),(2276,0.942),(2277,0.949),(2278,0.957),(2279,0.956),(2280,0.954),(2281,0.952),(2282,0.951),(2283,0.952),(2284,0.954),(2285,0.96),(2286,0.966),(2287,0.97),(2288,0.975),(2289,0.98),(2290,0.985),(2291,0.978),(2292,0.971),(2293,0.973),(2294,0.972),(2295,0.97),(2296,0.982),(2297,0.993),(2298,0.994),(2299,0.996),(2300,0.989),(2301,0.983),(2302,0.977),(2303,0.972),(2304,0.986),(2305,1.0),(2306,0.999),(2307,0.998),(2308,0.985),(2309,0.971),(2310,0.968),(2311,0.967),(2312,0.967),(2313,0.965),(2314,0.962),(2315,0.956),(2316,0.949),(2317,0.936),(2318,0.923),(2319,0.926),(2320,0.929),(2321,0.923),(2322,0.917),(2323,0.934),(2324,0.919),(2325,0.903),(2326,0.914),(2327,0.926),(2328,0.921),(2329,0.916),(2330,0.929),(2331,0.942),(2332,0.933),(2333,0.924),(2334,0.922),(2335,0.92),(2336,0.891),(2337,0.863),(2338,0.844),(2339,0.824),(2340,0.775),(2341,0.729),(2342,0.684),(2343,0.633),(2344,0.583),(2345,0.531),(2346,0.48),(2347,0.429),(2348,0.378),(2349,0.326),(2350,0.275),(2351,0.254),(2352,0.233),(2353,0.202),(2354,0.171),(2355,0.131),(2356,0.121),(2357,0.111),(2358,0.096),(2359,0.081),(2360,0.075),(2361,0.069),(2362,0.057),(2363,0.046),(2364,0.038),(2365,0.029),(2366,0.034),(2367,0.038),(2368,0.018),(2369,0.0),(2370,0.013),(2371,0.029),(2372,0.023),(2373,0.016),(2374,0.009),(2375,0.013),(2376,0.017),(2377,0.01),(2378,0.003),(2379,0.009),(2380,0.015),(2381,0.007)]",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToLandsat7Etm\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToLandsat89Oli",
    "label": "Spectral resampling (to Landsat 8/9 OLI)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the Landsat missions website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat89Oli",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToLandsat89Oli",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();responses['Blue'] = [(443,0.001),(444,0.002),(445,0.004),(446,0.007),(447,0.013),(448,0.027),(449,0.059),(450,0.131),(451,0.271),(452,0.494),(453,0.724),(454,0.858),(455,0.894),(456,0.903),(457,0.911),(458,0.91),(459,0.899),(460,0.898),(461,0.89),(462,0.884),(463,0.877),(464,0.881),(465,0.875),(466,0.88),(467,0.887),(468,0.892),(469,0.888),(470,0.861),(471,0.849),(472,0.841),(473,0.828),(474,0.844),(475,0.866),(476,0.868),(477,0.89),(478,0.913),(479,0.91),(480,0.919),(481,0.932),(482,0.932),(483,0.954),(484,0.956),(485,0.962),(486,0.956),(487,0.953),(488,0.979),(489,0.989),(490,0.986),(491,0.989),(492,0.982),(493,0.969),(494,0.967),(495,0.977),(496,0.989),(497,0.981),(498,0.967),(499,0.955),(500,0.964),(501,0.966),(502,0.967),(503,0.982),(504,0.982),(505,0.966),(506,0.963),(507,0.972),(508,0.996),(509,1.0),(510,0.956),(511,0.845),(512,0.535),(513,0.191),(514,0.048),(515,0.014),(516,0.005),(517,0.003),(518,0.002),(519,0.001)];responses['Green'] = [(519,0.001),(520,0.002),(521,0.003),(522,0.003),(523,0.005),(524,0.007),(525,0.01),(526,0.016),(527,0.026),(528,0.041),(529,0.071),(530,0.123),(531,0.212),(532,0.354),(533,0.546),(534,0.741),(535,0.865),(536,0.927),(537,0.955),(538,0.954),(539,0.959),(540,0.961),(541,0.965),(542,0.97),(543,0.952),(544,0.961),(545,0.978),(546,0.978),(547,0.977),(548,0.981),(549,0.991),(550,1.0),(551,0.992),(552,0.983),(553,0.984),(554,0.978),(555,0.965),(556,0.957),(557,0.946),(558,0.948),(559,0.959),(560,0.967),(561,0.978),(562,0.966),(563,0.953),(564,0.958),(565,0.97),(566,0.979),(567,0.983),(568,0.981),(569,0.975),(570,0.967),(571,0.979),(572,0.978),(573,0.976),(574,0.974),(575,0.98),(576,0.969),(577,0.969),(578,0.968),(579,0.983),(580,0.98),(581,0.964),(582,0.969),(583,0.984),(584,0.987),(585,0.974),(586,0.946),(587,0.904),(588,0.809),(589,0.685),(590,0.525),(591,0.345),(592,0.19),(593,0.088),(594,0.035),(595,0.014),(596,0.006),(597,0.003),(598,0.001)];responses['Red'] = [(628,0.002),(629,0.004),(630,0.007),(631,0.015),(632,0.03),(633,0.067),(634,0.149),(635,0.3),(636,0.527),(637,0.764),(638,0.905),(639,0.948),(640,0.951),(641,0.947),(642,0.952),(643,0.963),(644,0.975),(645,0.984),(646,0.984),(647,0.983),(648,0.983),(649,0.974),(650,0.959),(651,0.956),(652,0.956),(653,0.953),(654,0.957),(655,0.982),(656,1.0),(657,0.992),(658,0.985),(659,0.982),(660,0.977),(661,0.973),(662,0.981),(663,0.997),(664,0.992),(665,0.981),(666,0.964),(667,0.962),(668,0.971),(669,0.967),(670,0.967),(671,0.95),(672,0.849),(673,0.609),(674,0.316),(675,0.124),(676,0.046),(677,0.018),(678,0.007),(679,0.003),(680,0.001)];responses['NIR'] = [(838,0.001),(839,0.002),(840,0.003),(841,0.005),(842,0.007),(843,0.011),(844,0.017),(845,0.028),(846,0.048),(847,0.084),(848,0.145),(849,0.25),(850,0.404),(851,0.583),(852,0.745),(853,0.89),(854,0.96),(855,0.987),(856,0.973),(857,0.981),(858,0.996),(859,1.0),(860,0.99),(861,0.981),(862,0.976),(863,0.972),(864,0.957),(865,0.951),(866,0.947),(867,0.953),(868,0.951),(869,0.948),(870,0.94),(871,0.951),(872,0.956),(873,0.966),(874,0.97),(875,0.937),(876,0.891),(877,0.789),(878,0.635),(879,0.448),(880,0.289),(881,0.175),(882,0.1),(883,0.058),(884,0.035),(885,0.021),(886,0.012),(887,0.008),(888,0.005),(889,0.003),(890,0.002),(891,0.001)];responses['SWIR-1'] = [(1524,0.001),(1525,0.001),(1526,0.002),(1527,0.002),(1528,0.002),(1529,0.002),(1530,0.003),(1531,0.003),(1532,0.004),(1533,0.004),(1534,0.005),(1535,0.006),(1536,0.006),(1537,0.007),(1538,0.008),(1539,0.01),(1540,0.011),(1541,0.012),(1542,0.014),(1543,0.016),(1544,0.019),(1545,0.022),(1546,0.026),(1547,0.03),(1548,0.035),(1549,0.04),(1550,0.048),(1551,0.055),(1552,0.066),(1553,0.076),(1554,0.089),(1555,0.102),(1556,0.12),(1557,0.139),(1558,0.163),(1559,0.188),(1560,0.22),(1561,0.253),(1562,0.291),(1563,0.33),(1564,0.376),(1565,0.421),(1566,0.474),(1567,0.526),(1568,0.579),(1569,0.632),(1570,0.677),(1571,0.721),(1572,0.755),(1573,0.788),(1574,0.821),(1575,0.854),(1576,0.873),(1577,0.892),(1578,0.9),(1579,0.907),(1580,0.913),(1581,0.919),(1582,0.923),(1583,0.927),(1584,0.927),(1585,0.926),(1586,0.925),(1587,0.924),(1588,0.924),(1589,0.924),(1590,0.923),(1591,0.921),(1592,0.922),(1593,0.923),(1594,0.925),(1595,0.927),(1596,0.935),(1597,0.943),(1598,0.944),(1599,0.946),(1600,0.946),(1601,0.946),(1602,0.947),(1603,0.948),(1604,0.95),(1605,0.953),(1606,0.951),(1607,0.95),(1608,0.953),(1609,0.956),(1610,0.959),(1611,0.962),(1612,0.96),(1613,0.958),(1614,0.96),(1615,0.961),(1616,0.961),(1617,0.96),(1618,0.961),(1619,0.961),(1620,0.965),(1621,0.968),(1622,0.969),(1623,0.971),(1624,0.974),(1625,0.977),(1626,0.979),(1627,0.981),(1628,0.981),(1629,0.981),(1630,0.989),(1631,0.996),(1632,0.998),(1633,1.0),(1634,1.0),(1635,1.0),(1636,0.997),(1637,0.993),(1638,0.986),(1639,0.979),(1640,0.967),(1641,0.955),(1642,0.936),(1643,0.917),(1644,0.879),(1645,0.841),(1646,0.797),(1647,0.752),(1648,0.694),(1649,0.637),(1650,0.573),(1651,0.51),(1652,0.452),(1653,0.394),(1654,0.343),(1655,0.292),(1656,0.251),(1657,0.211),(1658,0.181),(1659,0.151),(1660,0.128),(1661,0.107),(1662,0.091),(1663,0.075),(1664,0.064),(1665,0.053),(1666,0.045),(1667,0.037),(1668,0.032),(1669,0.026),(1670,0.023),(1671,0.019),(1672,0.016),(1673,0.013),(1674,0.011),(1675,0.01),(1676,0.008),(1677,0.007),(1678,0.006),(1679,0.005),(1680,0.004),(1681,0.004),(1682,0.003),(1683,0.003),(1684,0.002),(1685,0.002),(1686,0.002),(1687,0.001),(1688,0.001)];responses['SWIR-2'] = [(2051,0.001),(2052,0.001),(2053,0.001),(2054,0.002),(2055,0.002),(2056,0.002),(2057,0.002),(2058,0.002),(2059,0.003),(2060,0.003),(2061,0.003),(2062,0.004),(2063,0.004),(2064,0.005),(2065,0.005),(2066,0.006),(2067,0.006),(2068,0.007),(2069,0.008),(2070,0.009),(2071,0.01),(2072,0.011),(2073,0.012),(2074,0.014),(2075,0.015),(2076,0.017),(2077,0.019),(2078,0.021),(2079,0.023),(2080,0.026),(2081,0.029),(2082,0.032),(2083,0.035),(2084,0.04),(2085,0.045),(2086,0.051),(2087,0.056),(2088,0.063),(2089,0.07),(2090,0.079),(2091,0.089),(2092,0.101),(2093,0.113),(2094,0.128),(2095,0.145),(2096,0.162),(2097,0.18),(2098,0.203),(2099,0.227),(2100,0.254),(2101,0.281),(2102,0.311),(2103,0.343),(2104,0.377),(2105,0.413),(2106,0.45),(2107,0.489),(2108,0.522),(2109,0.555),(2110,0.593),(2111,0.634),(2112,0.663),(2113,0.69),(2114,0.722),(2115,0.757),(2116,0.776),(2117,0.793),(2118,0.814),(2119,0.836),(2120,0.846),(2121,0.854),(2122,0.868),(2123,0.884),(2124,0.886),(2125,0.886),(2126,0.895),(2127,0.907),(2128,0.91),(2129,0.911),(2130,0.918),(2131,0.926),(2132,0.93),(2133,0.932),(2134,0.937),(2135,0.941),(2136,0.943),(2137,0.943),(2138,0.943),(2139,0.943),(2140,0.945),(2141,0.948),(2142,0.949),(2143,0.95),(2144,0.95),(2145,0.949),(2146,0.953),(2147,0.957),(2148,0.953),(2149,0.947),(2150,0.949),(2151,0.953),(2152,0.951),(2153,0.947),(2154,0.947),(2155,0.947),(2156,0.952),(2157,0.958),(2158,0.953),(2159,0.946),(2160,0.948),(2161,0.951),(2162,0.952),(2163,0.952),(2164,0.949),(2165,0.945),(2166,0.943),(2167,0.94),(2168,0.943),(2169,0.948),(2170,0.945),(2171,0.94),(2172,0.939),(2173,0.938),(2174,0.942),(2175,0.947),(2176,0.947),(2177,0.944),(2178,0.947),(2179,0.952),(2180,0.949),(2181,0.945),(2182,0.94),(2183,0.934),(2184,0.935),(2185,0.939),(2186,0.939),(2187,0.939),(2188,0.935),(2189,0.929),(2190,0.927),(2191,0.926),(2192,0.931),(2193,0.937),(2194,0.934),(2195,0.928),(2196,0.931),(2197,0.936),(2198,0.936),(2199,0.934),(2200,0.935),(2201,0.938),(2202,0.946),(2203,0.957),(2204,0.956),(2205,0.952),(2206,0.957),(2207,0.963),(2208,0.964),(2209,0.964),(2210,0.964),(2211,0.962),(2212,0.963),(2213,0.964),(2214,0.962),(2215,0.961),(2216,0.959),(2217,0.958),(2218,0.958),(2219,0.958),(2220,0.953),(2221,0.947),(2222,0.952),(2223,0.959),(2224,0.96),(2225,0.96),(2226,0.955),(2227,0.948),(2228,0.952),(2229,0.959),(2230,0.961),(2231,0.961),(2232,0.956),(2233,0.949),(2234,0.953),(2235,0.96),(2236,0.964),(2237,0.967),(2238,0.964),(2239,0.96),(2240,0.965),(2241,0.973),(2242,0.978),(2243,0.981),(2244,0.983),(2245,0.984),(2246,0.985),(2247,0.985),(2248,0.991),(2249,1.0),(2250,0.998),(2251,0.993),(2252,0.992),(2253,0.993),(2254,0.996),(2255,1.0),(2256,0.999),(2257,0.997),(2258,0.994),(2259,0.991),(2260,0.988),(2261,0.984),(2262,0.986),(2263,0.989),(2264,0.985),(2265,0.978),(2266,0.975),(2267,0.973),(2268,0.974),(2269,0.977),(2270,0.976),(2271,0.975),(2272,0.974),(2273,0.974),(2274,0.968),(2275,0.96),(2276,0.957),(2277,0.955),(2278,0.955),(2279,0.956),(2280,0.947),(2281,0.937),(2282,0.922),(2283,0.907),(2284,0.895),(2285,0.884),(2286,0.855),(2287,0.824),(2288,0.785),(2289,0.744),(2290,0.699),(2291,0.652),(2292,0.603),(2293,0.553),(2294,0.503),(2295,0.453),(2296,0.404),(2297,0.356),(2298,0.316),(2299,0.278),(2300,0.245),(2301,0.212),(2302,0.186),(2303,0.162),(2304,0.141),(2305,0.122),(2306,0.107),(2307,0.092),(2308,0.08),(2309,0.069),(2310,0.061),(2311,0.053),(2312,0.046),(2313,0.04),(2314,0.036),(2315,0.031),(2316,0.028),(2317,0.024),(2318,0.021),(2319,0.019),(2320,0.017),(2321,0.015),(2322,0.013),(2323,0.011),(2324,0.01),(2325,0.009),(2326,0.008),(2327,0.007),(2328,0.006),(2329,0.006),(2330,0.005),(2331,0.004),(2332,0.004),(2333,0.003),(2334,0.003),(2335,0.003),(2336,0.002),(2337,0.002),(2338,0.002),(2339,0.002),(2340,0.001),(2341,0.001)]",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToLandsat89Oli\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToPrisma",
    "label": "Spectral resampling (to PRISMA)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the PRISMA mission website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToPrisma",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToPrisma",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();wavelength = [402.4,411.3,419.4,427.0,434.3,441.7,449.0,456.4,463.7,470.9,478.2,485.4,492.7,500.1,507.7,515.2,522.9,530.7,538.5,546.5,554.6,562.7,571.0,579.4,587.8,596.5,605.4,614.2,623.2,632.1,641.3,650.8,660.3,669.8,679.5,689.4,699.1,709.0,719.2,729.2,739.4,749.7,760.1,770.5,780.9,791.4,801.9,812.5,823.1,833.8,844.4,855.2,865.9,876.6,887.3,898.0,908.6,919.2,929.4,939.9,951.4,962.3,972.6,943.0,951.0,959.5,969.4,978.7,988.4,998.4,1008.2,1018.0,1028.8,1037.8,1047.4,1057.4,1067.6,1078.0,1088.6,1099.1,1109.7,1120.5,1131.1,1141.9,1152.5,1163.5,1174.5,1185.4,1196.2,1207.1,1217.7,1229.0,1240.1,1250.8,1262.3,1273.3,1284.3,1295.2,1306.0,1317.0,1328.1,1338.9,1349.6,1360.8,1372.7,1383.0,1394.5,1405.4,1416.3,1427.1,1438.2,1448.9,1459.1,1469.7,1480.6,1491.2,1501.8,1512.4,1523.0,1533.6,1544.0,1554.6,1565.1,1575.4,1585.6,1596.0,1606.2,1616.6,1626.8,1636.9,1647.0,1656.8,1667.0,1677.1,1687.2,1697.0,1706.8,1716.6,1726.4,1736.3,1745.9,1755.5,1765.3,1774.9,1784.4,1793.7,1803.4,1812.8,1822.1,1831.7,1841.0,1850.3,1859.3,1868.0,1878.5,1886.8,1895.8,1904.6,1914.0,1923.1,1932.0,1940.8,1949.6,1958.4,1967.1,1975.8,1984.5,1993.3,2001.8,2010.4,2019.0,2027.5,2036.0,2044.4,2052.8,2061.1,2069.5,2077.8,2086.1,2094.4,2102.5,2110.8,2119.0,2127.1,2135.2,2143.2,2151.1,2159.3,2167.3,2175.1,2183.2,2190.8,2198.9,2206.6,2214.3,2222.2,2229.8,2237.6,2245.2,2252.8,2260.6,2268.0,2275.8,2283.3,2290.6,2298.3,2305.5,2312.9,2320.6,2327.6,2335.2,2342.6,2349.6,2357.0,2364.4,2371.3,2378.5,2385.8,2392.8,2399.8,2407.3,2414.2,2421.0,2428.4,2435.3,2442.2,2448.9,2456.3,2462.8,2469.4,2476.8,2483.6,2490.0,2496.9];fwhm = [11.4,10.6,9.8,9.4,9.3,9.2,9.1,9.1,9.0,9.0,9.0,9.0,9.2,9.3,9.4,9.5,9.6,9.7,9.8,10.0,10.1,10.2,10.3,10.4,10.5,10.8,11.0,11.0,11.2,11.2,11.5,11.6,11.7,11.8,12.0,12.1,12.0,12.4,12.4,12.4,12.5,12.6,12.8,12.7,12.8,12.8,12.9,12.9,13.0,13.0,13.1,13.1,13.2,13.1,13.1,13.1,13.1,12.9,12.8,13.2,13.5,13.0,12.9,10.9,11.0,12.0,12.1,12.2,12.3,12.7,12.4,13.0,13.0,13.3,13.5,13.7,13.9,14.0,14.1,14.1,14.4,14.0,14.3,14.1,14.3,14.7,14.3,14.4,14.3,14.6,14.4,14.7,14.4,14.7,14.9,14.6,14.5,14.4,14.5,14.6,14.7,14.4,14.5,15.1,14.5,14.8,14.2,14.4,14.3,14.1,14.7,13.9,13.7,14.2,14.2,14.0,14.1,14.0,13.9,13.9,13.7,13.9,13.7,13.6,13.6,13.6,13.5,13.7,13.3,13.2,13.2,12.6,13.4,12.9,13.0,13.1,13.0,12.7,12.6,12.7,12.9,12.9,12.4,12.3,12.5,12.5,12.3,12.2,12.9,12.2,12.4,12.4,12.1,11.1,12.5,11.6,11.5,12.5,11.6,12.0,11.6,11.8,11.5,11.4,11.5,11.4,11.6,11.2,11.4,11.2,11.3,11.0,11.3,10.9,11.0,10.9,11.1,10.9,11.0,10.8,10.8,10.8,10.8,10.6,10.7,10.5,10.6,10.8,10.2,10.7,10.3,10.3,10.6,10.1,10.4,10.1,10.3,10.3,10.1,10.2,10.2,9.9,10.2,9.8,10.0,10.0,9.7,10.1,9.8,9.7,10.1,9.6,9.6,10.0,9.5,9.5,9.6,9.7,9.3,9.6,9.7,9.0,9.7,9.5,9.4,8.8,9.4,9.5,8.9,9.1,9.7,9.0,9.0,9.5];exec(\\\"for w,f in zip(wavelength,fwhm): responses[w] = f\\\")",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToPrisma\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToResponseFunctionLibrary",
    "label": "Spectral resampling (to response function library)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution, with spectral response function stored inside a spectral library. Each spectral profile defines a destination spectral band.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToResponseFunctionLibrary",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "SpectralResamplingToResponseFunctionLibrary",
        "name": "library",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToResponseFunctionLibrary",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "field",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Field with spectral profiles used as spectral response functions. If not selected, the default field is used. If that is also not specified, an error is raised.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "field",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToResponseFunctionLibrary\nraster=$raster\nlibrary=$library\nfield=$field\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToSentinel2Msi",
    "label": "Spectral resampling (to Sentinel-2 MSI)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution. For more information see the Sentinel-2 missions website.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToSentinel2Msi",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToSentinel2Msi",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "response",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from collections import OrderedDict;responses = OrderedDict();responses['B2 - Blue'] = [(439,0.01),(440,0.03),(441,0.027),(442,0.024),(443,0.02),(444,0.023),(445,0.025),(446,0.017),(447,0.021),(448,0.016),(449,0.021),(450,0.018),(451,0.018),(452,0.018),(453,0.019),(454,0.019),(455,0.027),(456,0.043),(457,0.072),(458,0.154),(459,0.328),(460,0.553),(461,0.71),(462,0.753),(463,0.752),(464,0.757),(465,0.763),(466,0.762),(467,0.785),(468,0.815),(469,0.862),(470,0.893),(471,0.92),(472,0.919),(473,0.913),(474,0.9),(475,0.89),(476,0.882),(477,0.876),(478,0.884),(479,0.907),(480,0.932),(481,0.939),(482,0.944),(483,0.922),(484,0.886),(485,0.847),(486,0.813),(487,0.782),(488,0.773),(489,0.772),(490,0.787),(491,0.812),(492,0.846),(493,0.888),(494,0.928),(495,0.951),(496,0.966),(497,0.969),(498,0.966),(499,0.958),(500,0.954),(501,0.952),(502,0.957),(503,0.966),(504,0.977),(505,0.977),(506,0.974),(507,0.959),(508,0.935),(509,0.902),(510,0.872),(511,0.844),(512,0.823),(513,0.815),(514,0.821),(515,0.84),(516,0.87),(517,0.915),(518,0.961),(519,0.992),(520,1.0),(521,0.984),(522,0.911),(523,0.74),(524,0.504),(525,0.305),(526,0.18),(527,0.107),(528,0.066),(529,0.042),(530,0.027),(531,0.014),(532,0.003)];responses['B3 - Green'] = [(538,0.014),(539,0.034),(540,0.073),(541,0.154),(542,0.317),(543,0.553),(544,0.749),(545,0.849),(546,0.898),(547,0.922),(548,0.926),(549,0.911),(550,0.888),(551,0.865),(552,0.847),(553,0.839),(554,0.845),(555,0.862),(556,0.888),(557,0.924),(558,0.96),(559,0.987),(560,1.0),(561,0.999),(562,0.981),(563,0.945),(564,0.898),(565,0.856),(566,0.818),(567,0.789),(568,0.765),(569,0.75),(570,0.751),(571,0.761),(572,0.782),(573,0.799),(574,0.81),(575,0.814),(576,0.774),(577,0.629),(578,0.404),(579,0.215),(580,0.107),(581,0.048),(582,0.018),(583,0.001)];responses['B4 - Red'] = [(646,0.001),(647,0.026),(648,0.117),(649,0.391),(650,0.75),(651,0.945),(652,0.98),(653,0.994),(654,1.0),(655,0.995),(656,0.991),(657,0.977),(658,0.941),(659,0.879),(660,0.816),(661,0.773),(662,0.754),(663,0.76),(664,0.783),(665,0.81),(666,0.836),(667,0.861),(668,0.886),(669,0.911),(670,0.934),(671,0.95),(672,0.959),(673,0.96),(674,0.959),(675,0.958),(676,0.955),(677,0.944),(678,0.895),(679,0.744),(680,0.477),(681,0.23),(682,0.08),(683,0.026),(684,0.004)];responses['B5 - Red edge 1'] = [(695,0.028),(696,0.124),(697,0.394),(698,0.761),(699,0.971),(700,0.999),(701,1.0),(702,0.994),(703,0.983),(704,0.967),(705,0.948),(706,0.927),(707,0.904),(708,0.886),(709,0.867),(710,0.791),(711,0.588),(712,0.263),(713,0.057),(714,0.006)];responses['B6 - Red edge 2'] = [(731,0.002),(732,0.055),(733,0.258),(734,0.647),(735,0.892),(736,0.902),(737,0.915),(738,0.941),(739,0.963),(740,0.975),(741,0.977),(742,0.987),(743,1.0),(744,0.989),(745,0.972),(746,0.901),(747,0.607),(748,0.205),(749,0.027)];responses['B7 - Red edge 3'] = [(770,0.012),(771,0.052),(772,0.166),(773,0.369),(774,0.637),(775,0.861),(776,0.97),(777,0.991),(778,0.999),(779,1.0),(780,0.977),(781,0.926),(782,0.866),(783,0.82),(784,0.794),(785,0.791),(786,0.804),(787,0.819),(788,0.826),(789,0.82),(790,0.792),(791,0.721),(792,0.588),(793,0.414),(794,0.231),(795,0.099),(796,0.027),(797,0.005)];responses['B8 - NIR'] = [(774,0.007),(775,0.018),(776,0.032),(777,0.053),(778,0.083),(779,0.127),(780,0.196),(781,0.302),(782,0.436),(783,0.571),(784,0.698),(785,0.803),(786,0.891),(787,0.953),(788,0.989),(789,1.0),(790,0.988),(791,0.964),(792,0.942),(793,0.937),(794,0.942),(795,0.954),(796,0.968),(797,0.98),(798,0.985),(799,0.986),(800,0.984),(801,0.978),(802,0.977),(803,0.978),(804,0.981),(805,0.988),(806,0.989),(807,0.986),(808,0.981),(809,0.971),(810,0.957),(811,0.939),(812,0.917),(813,0.896),(814,0.873),(815,0.852),(816,0.825),(817,0.801),(818,0.782),(819,0.764),(820,0.75),(821,0.739),(822,0.731),(823,0.723),(824,0.725),(825,0.726),(826,0.723),(827,0.722),(828,0.716),(829,0.712),(830,0.708),(831,0.702),(832,0.699),(833,0.701),(834,0.707),(835,0.718),(836,0.731),(837,0.748),(838,0.768),(839,0.784),(840,0.797),(841,0.803),(842,0.805),(843,0.802),(844,0.797),(845,0.789),(846,0.777),(847,0.765),(848,0.751),(849,0.737),(850,0.723),(851,0.704),(852,0.684),(853,0.665),(854,0.647),(855,0.63),(856,0.616),(857,0.602),(858,0.59),(859,0.58),(860,0.571),(861,0.561),(862,0.552),(863,0.546),(864,0.54),(865,0.535),(866,0.531),(867,0.53),(868,0.53),(869,0.53),(870,0.532),(871,0.533),(872,0.532),(873,0.533),(874,0.532),(875,0.531),(876,0.53),(877,0.53),(878,0.533),(879,0.537),(880,0.542),(881,0.549),(882,0.555),(883,0.56),(884,0.558),(885,0.548),(886,0.531),(887,0.508),(888,0.478),(889,0.451),(890,0.428),(891,0.411),(892,0.4),(893,0.401),(894,0.408),(895,0.421),(896,0.43),(897,0.425),(898,0.391),(899,0.33),(900,0.257),(901,0.182),(902,0.117),(903,0.07),(904,0.043),(905,0.026),(906,0.016),(907,0.004)];responses['B8A - Narrow NIR'] = [(847,0.002),(848,0.002),(849,0.013),(850,0.026),(851,0.053),(852,0.108),(853,0.222),(854,0.397),(855,0.61),(856,0.817),(857,0.932),(858,0.972),(859,0.975),(860,0.975),(861,0.973),(862,0.976),(863,0.98),(864,0.987),(865,0.991),(866,0.997),(867,1.0),(868,0.999),(869,0.996),(870,0.995),(871,1.0),(872,0.996),(873,0.924),(874,0.741),(875,0.49),(876,0.25),(877,0.112),(878,0.048),(879,0.023),(880,0.011),(881,0.001)];# responses['B9 - Water vapour'] = [(932,0.017),(933,0.061),(934,0.174),(935,0.389),(936,0.665),(937,0.875),(938,0.937),(939,0.968),(940,0.989),(941,0.995),(942,1.0),(943,0.978),(944,0.981),(945,0.992),(946,0.988),(947,0.994),(948,0.983),(949,0.978),(950,0.95),(951,0.953),(952,0.922),(953,0.856),(954,0.71),(955,0.464),(956,0.215),(957,0.065),(958,0.016)];# responses['B10 - Cirrus'] = [(1350,0.001),(1351,0.002),(1352,0.004),(1353,0.008),(1354,0.019),(1355,0.045),(1356,0.102),(1357,0.201),(1358,0.342),(1359,0.506),(1360,0.662),(1361,0.783),(1362,0.861),(1363,0.91),(1364,0.942),(1365,0.962),(1366,0.974),(1367,0.982),(1368,0.988),(1369,0.993),(1370,0.996),(1371,0.999),(1372,1.0),(1373,0.999),(1374,0.996),(1375,0.991),(1376,0.985),(1377,0.978),(1378,0.97),(1379,0.961),(1380,0.949),(1381,0.933),(1382,0.915),(1383,0.894),(1384,0.869),(1385,0.831),(1386,0.765),(1387,0.655),(1388,0.508),(1389,0.351),(1390,0.219),(1391,0.127),(1392,0.068),(1393,0.033),(1394,0.014),(1395,0.005),(1396,0.002),(1397,0.001)];responses['B11 - SWIR-1'] = [(1551,0.001),(1552,0.002),(1553,0.002),(1554,0.004),(1555,0.005),(1556,0.008),(1557,0.013),(1558,0.019),(1559,0.028),(1560,0.04),(1561,0.055),(1562,0.075),(1563,0.101),(1564,0.135),(1565,0.183),(1566,0.247),(1567,0.331),(1568,0.43),(1569,0.538),(1570,0.647),(1571,0.744),(1572,0.815),(1573,0.859),(1574,0.88),(1575,0.887),(1576,0.889),(1577,0.891),(1578,0.898),(1579,0.907),(1580,0.917),(1581,0.927),(1582,0.935),(1583,0.942),(1584,0.948),(1585,0.951),(1586,0.954),(1587,0.956),(1588,0.958),(1589,0.961),(1590,0.963),(1591,0.966),(1592,0.968),(1593,0.971),(1594,0.973),(1595,0.976),(1596,0.979),(1597,0.98),(1598,0.981),(1599,0.981),(1600,0.981),(1601,0.981),(1602,0.981),(1603,0.98),(1604,0.981),(1605,0.983),(1606,0.985),(1607,0.988),(1608,0.99),(1609,0.992),(1610,0.993),(1611,0.993),(1612,0.99),(1613,0.987),(1614,0.984),(1615,0.98),(1616,0.976),(1617,0.973),(1618,0.97),(1619,0.968),(1620,0.966),(1621,0.966),(1622,0.966),(1623,0.967),(1624,0.97),(1625,0.973),(1626,0.979),(1627,0.983),(1628,0.988),(1629,0.992),(1630,0.995),(1631,0.998),(1632,0.999),(1633,0.999),(1634,0.999),(1635,0.999),(1636,0.999),(1637,1.0),(1638,1.0),(1639,1.0),(1640,1.0),(1641,0.997),(1642,0.992),(1643,0.986),(1644,0.979),(1645,0.97),(1646,0.961),(1647,0.953),(1648,0.947),(1649,0.942),(1650,0.939),(1651,0.935),(1652,0.928),(1653,0.912),(1654,0.881),(1655,0.825),(1656,0.743),(1657,0.642),(1658,0.534),(1659,0.427),(1660,0.324),(1661,0.234),(1662,0.164),(1663,0.11),(1664,0.072),(1665,0.046),(1666,0.029),(1667,0.019),(1668,0.013),(1669,0.009),(1670,0.007),(1671,0.005),(1672,0.003),(1673,0.002),(1674,0.002),(1675,0.001),(1676,0.001)];responses['B12 - SWIR-2'] = [(2079,0.001),(2080,0.003),(2081,0.004),(2082,0.007),(2083,0.008),(2084,0.008),(2085,0.009),(2086,0.009),(2087,0.01),(2088,0.011),(2089,0.012),(2090,0.013),(2091,0.015),(2092,0.017),(2093,0.02),(2094,0.023),(2095,0.028),(2096,0.033),(2097,0.04),(2098,0.049),(2099,0.06),(2100,0.073),(2101,0.091),(2102,0.111),(2103,0.137),(2104,0.168),(2105,0.203),(2106,0.243),(2107,0.285),(2108,0.327),(2109,0.368),(2110,0.408),(2111,0.445),(2112,0.477),(2113,0.503),(2114,0.525),(2115,0.543),(2116,0.557),(2117,0.569),(2118,0.579),(2119,0.589),(2120,0.599),(2121,0.61),(2122,0.621),(2123,0.634),(2124,0.649),(2125,0.664),(2126,0.68),(2127,0.696),(2128,0.712),(2129,0.727),(2130,0.741),(2131,0.757),(2132,0.772),(2133,0.786),(2134,0.798),(2135,0.81),(2136,0.82),(2137,0.829),(2138,0.837),(2139,0.844),(2140,0.851),(2141,0.853),(2142,0.855),(2143,0.856),(2144,0.858),(2145,0.86),(2146,0.861),(2147,0.863),(2148,0.865),(2149,0.867),(2150,0.87),(2151,0.874),(2152,0.879),(2153,0.882),(2154,0.886),(2155,0.889),(2156,0.893),(2157,0.897),(2158,0.9),(2159,0.903),(2160,0.905),(2161,0.906),(2162,0.906),(2163,0.906),(2164,0.905),(2165,0.905),(2166,0.904),(2167,0.903),(2168,0.903),(2169,0.902),(2170,0.902),(2171,0.903),(2172,0.904),(2173,0.905),(2174,0.906),(2175,0.908),(2176,0.91),(2177,0.913),(2178,0.916),(2179,0.918),(2180,0.921),(2181,0.924),(2182,0.927),(2183,0.93),(2184,0.932),(2185,0.934),(2186,0.936),(2187,0.937),(2188,0.938),(2189,0.938),(2190,0.938),(2191,0.94),(2192,0.943),(2193,0.943),(2194,0.943),(2195,0.942),(2196,0.941),(2197,0.938),(2198,0.937),(2199,0.935),(2200,0.933),(2201,0.927),(2202,0.921),(2203,0.915),(2204,0.911),(2205,0.908),(2206,0.907),(2207,0.908),(2208,0.911),(2209,0.916),(2210,0.923),(2211,0.921),(2212,0.919),(2213,0.919),(2214,0.921),(2215,0.925),(2216,0.928),(2217,0.932),(2218,0.937),(2219,0.941),(2220,0.947),(2221,0.951),(2222,0.954),(2223,0.957),(2224,0.96),(2225,0.963),(2226,0.965),(2227,0.966),(2228,0.967),(2229,0.966),(2230,0.965),(2231,0.965),(2232,0.964),(2233,0.962),(2234,0.959),(2235,0.957),(2236,0.955),(2237,0.954),(2238,0.953),(2239,0.952),(2240,0.952),(2241,0.952),(2242,0.953),(2243,0.954),(2244,0.957),(2245,0.961),(2246,0.964),(2247,0.968),(2248,0.973),(2249,0.977),(2250,0.983),(2251,0.987),(2252,0.991),(2253,0.994),(2254,0.997),(2255,0.999),(2256,1.0),(2257,1.0),(2258,0.999),(2259,0.997),(2260,0.994),(2261,0.99),(2262,0.984),(2263,0.976),(2264,0.968),(2265,0.958),(2266,0.948),(2267,0.938),(2268,0.928),(2269,0.917),(2270,0.906),(2271,0.894),(2272,0.882),(2273,0.869),(2274,0.855),(2275,0.841),(2276,0.826),(2277,0.81),(2278,0.792),(2279,0.772),(2280,0.749),(2281,0.72),(2282,0.688),(2283,0.651),(2284,0.61),(2285,0.566),(2286,0.521),(2287,0.475),(2288,0.429),(2289,0.386),(2290,0.342),(2291,0.301),(2292,0.263),(2293,0.228),(2294,0.196),(2295,0.168),(2296,0.145),(2297,0.125),(2298,0.108),(2299,0.094),(2300,0.082),(2301,0.072),(2302,0.063),(2303,0.055),(2304,0.048),(2305,0.043),(2306,0.039),(2307,0.035),(2308,0.032),(2309,0.03),(2310,0.027),(2311,0.026),(2312,0.024),(2313,0.022),(2314,0.019),(2315,0.016),(2316,0.011),(2317,0.007),(2318,0.007),(2319,0.005),(2320,0.002)]",
        "description": "Python code specifying the spectral response function.",
        "label": "response",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToSentinel2Msi\nraster=$raster\nresponse=$response\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "SpectralResamplingToSpectralRasterLayerWavelengthAndFwhm",
    "label": "Spectral resampling (to spectral raster layer wavelength and FWHM)",
    "version": "3.10",
    "description": "Spectrally resample a spectral raster layer by applying spectral response function convolution, with spectral response function derived from wavelength and FWHM information stored inside a spectral raster layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "SpectralResamplingToSpectralRasterLayerWavelengthAndFwhm",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "SpectralResamplingToSpectralRasterLayerWavelengthAndFwhm",
        "name": null,
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "SpectralResamplingToSpectralRasterLayerWavelengthAndFwhm",
        "name": "outputResampledRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "saveResponseFunction",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to save the spectral response function library as *.srf.gpkg sidecar file.",
        "label": "saveResponseFunction",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:SpectralResamplingToSpectralRasterLayerWavelengthAndFwhm\nraster=$raster\nresponseRaster=$responseRaster\nsaveResponseFunction=$saveResponseFunction\noutputResampledRaster=$outputResampledRaster"
  },
  {
    "id": "FitFactoranalysis",
    "label": "Fit Factor Analysis",
    "version": "3.10",
    "description": "Factor Analysis. A simple linear generative model with Gaussian latent variables. The observations are assumed to be caused by a linear transformation of lower dimensional latent factors and added Gaussian noise. Without loss of generality the factors are distributed according to a Gaussian with zero mean and unit covariance. The noise is also zero mean and has an arbitrary diagonal covariance matrix. If we would restrict the model further, by assuming that the Gaussian noise is even isotropic (all diagonal entries are the same) we would obtain ProbabilisticPCA. FactorAnalysis performs a maximum likelihood estimate of the so-called loading matrix, the transformation of the latent variables to the observed ones, using SVD based approach.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitFactoranalysis",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitFactoranalysis",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.decomposition import FactorAnalysis;factorAnalysis = FactorAnalysis(n_components=3);transformer = make_pipeline(StandardScaler(), factorAnalysis)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features.",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitFactoranalysis\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitFastica",
    "label": "Fit Fast ICA",
    "version": "3.10",
    "description": "FastICA: a fast algorithm for Independent Component Analysis.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitFastica",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitFastica",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.decomposition import FastICA;fastICA = FastICA(n_components=3);transformer = make_pipeline(StandardScaler(), fastICA)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features.",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitFastica\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitFeatureagglomeration",
    "label": "Fit Feature Agglomeration",
    "version": "3.10",
    "description": "Agglomerate features. Recursively merges pair of clusters of features.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitFeatureagglomeration",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitFeatureagglomeration",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.cluster import FeatureAgglomeration;transformer = FeatureAgglomeration(n_clusters=3)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features.",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitFeatureagglomeration\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitKernelpca",
    "label": "Fit Kernel PCA",
    "version": "3.10",
    "description": "Kernel Principal component analysis (KPCA). Non-linear dimensionality reduction through the use of kernels",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitKernelpca",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitKernelpca",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.decomposition import KernelPCA;kernelPCA = KernelPCA(n_components=3, fit_inverse_transform=True);transformer = make_pipeline(StandardScaler(), kernelPCA)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features.",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitKernelpca\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitMaxabsscaler",
    "label": "Fit Max Abs Scaler",
    "version": "3.10",
    "description": "Scale each feature by its maximum absolute value. This estimator scales and translates each feature individually such that the maximal absolute value of each feature in the training set will be 1.0.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitMaxabsscaler",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitMaxabsscaler",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import MaxAbsScaler;transformer = MaxAbsScaler()",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitMaxabsscaler\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitMinmaxscaler",
    "label": "Fit Min Max Scaler",
    "version": "3.10",
    "description": "Transform features by scaling each feature to a given range. This estimator scales and translates each feature individually such that it is in the given range on the training set, e.g. between zero and one.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitMinmaxscaler",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitMinmaxscaler",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import MinMaxScaler;transformer = MinMaxScaler(feature_range=(0, 1), clip=False)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitMinmaxscaler\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitNormalizer",
    "label": "Fit Normalizer",
    "version": "3.10",
    "description": "Normalize samples individually to unit norm. Each sample (i.e. each row of the data matrix) with at least one non zero component is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitNormalizer",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitNormalizer",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import Normalizer;transformer = Normalizer()",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitNormalizer\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitPca",
    "label": "Fit PCA",
    "version": "3.10",
    "description": "Principal component analysis (PCA). Linear dimensionality reduction using Singular Value Decomposition of the data to project it to a lower dimensional space. The input data is centered but not scaled for each feature before applying the SVD.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitPca",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitPca",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.pipeline import make_pipeline;from sklearn.preprocessing import StandardScaler;from sklearn.decomposition import PCA;pca = PCA(n_components=0.95);transformer = make_pipeline(StandardScaler(), pca)",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitPca\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitQuantiletransformer",
    "label": "Fit Quantile Transformer",
    "version": "3.10",
    "description": "Transform features using quantiles information. This method transforms the features to follow a uniform or a normal distribution. Therefore, for a given feature, this transformation tends to spread out the most frequent values. It also reduces the impact of (marginal) outliers: this is therefore a robust preprocessing scheme. The transformation is applied on each feature independently. First an estimate of the cumulative distribution function of a feature is used to map the original values to a uniform distribution. The obtained values are then mapped to the desired output distribution using the associated quantile function. Features values of new/unseen data that fall below or above the fitted range will be mapped to the bounds of the output distribution. Note that this transform is non-linear. It may distort linear correlations between variables measured at the same scale but renders variables measured at different scales more directly comparable.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitQuantiletransformer",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitQuantiletransformer",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import QuantileTransformer;transformer = QuantileTransformer()",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitQuantiletransformer\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitRobustscaler",
    "label": "Fit Robust Scaler",
    "version": "3.10",
    "description": "Scale features using statistics that are robust to outliers. This Scaler removes the median and scales the data according to the quantile range (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and the 3rd quartile (75th quantile). Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Median and interquartile range are then stored to be used on later data using the transform method. Standardization of a dataset is a common requirement for many machine learning estimators. Typically this is done by removing the mean and scaling to unit variance. However, outliers can often influence the sample mean / variance in a negative way. In such cases, the median and the interquartile range often give better results.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitRobustscaler",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitRobustscaler",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import RobustScaler;transformer = RobustScaler(quantile_range=(25, 75))",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitRobustscaler\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "FitStandardscaler",
    "label": "Fit Standard Scaler",
    "version": "3.10",
    "description": "Standardize features by removing the mean and scaling to unit variance. The standard score of a sample x is calculated as: z = (x - u) / s where u is the mean of the training samples or zero if with_mean=False, and s is the standard deviation of the training samples or one if with_std=False. Centering and scaling happen independently on each feature by computing the relevant statistics on the samples in the training set. Mean and standard deviation are then stored to be used on later data using transform. Standardization of a dataset is a common requirement for many machine learning estimators: they might behave badly if the individual features do not more or less look like standard normally distributed data (e.g. Gaussian with 0 mean and unit variance). For instance many elements used in the objective function of a learning algorithm (such as the RBF kernel of Support Vector Machines or the L1 and L2 regularizers of linear models) assume that all features are centered around 0 and have variance in the same order. If a feature has a variance that is orders of magnitude larger that others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "FitStandardscaler",
        "name": "featureRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "FitStandardscaler",
        "name": "outputTransformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.pkl"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "transformer",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "from sklearn.preprocessing import StandardScaler;transformer = StandardScaler()",
        "description": "Scikit-learn python code. See FactorAnalysis for information on different parameters.",
        "label": "transformer",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "sampleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Approximate number of samples drawn from raster. If 0, whole raster will be used. Note that this is only a hint for limiting the number of rows and columns.",
        "label": "sampleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "dataset",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Training dataset pickle file used for fitting the transformer. Mutually exclusive with parameter: Raster layer with features",
        "label": "dataset",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:FitStandardscaler\ntransformer=$transformer\nfactorAnalysis=$factorAnalysis\nfeatureRaster=$featureRaster\nsampleSize=$sampleSize\ndataset=$dataset\noutputTransformer=$outputTransformer"
  },
  {
    "id": "TransformRasterLayer",
    "label": "Transform raster layer",
    "version": "3.10",
    "description": "Uses a fitted transformer to transform a raster layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "TransformRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "TransformRasterLayer",
        "name": "transformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "TransformRasterLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:TransformRasterLayer\nraster=$raster\ntransformer=$transformer\noutputRaster=$outputRaster"
  },
  {
    "id": "InverseTransformRasterLayer",
    "label": "Inverse transform raster layer",
    "version": "3.10",
    "description": "Uses a fitted transformer to inverse transform a raster layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "InverseTransformRasterLayer",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "InverseTransformRasterLayer",
        "name": "transformer",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "InverseTransformRasterLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
    ],
    "templatecontents": "run\nenmapbox:InverseTransformRasterLayer\nraster=$raster\ntransformer=$transformer\noutputRaster=$outputRaster"
  },
  {
    "id": "RegressionBasedUnmixing",
    "label": "Regression-based unmixing",
    "version": "3.10",
    "description": "Implementation of the regression-based unmixing approach 'Ensemble Learning From Synthetically Mixed Training Data for Quantifying Urban Land Cover With Support Vector Regression' in IEEE Journal of Selected Topics in Applied Earth Observations and Remote Sensing, vol. 10, no. 4, pp. 1640-1650, April 2017.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RegressionBasedUnmixing",
        "name": "dataset",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      },
      {
        "id": null,
        "parentId": "RegressionBasedUnmixing",
        "name": "raster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RegressionBasedUnmixing",
        "name": "outputFraction",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      },
      {
        "id": null,
        "parentId": "RegressionBasedUnmixing",
        "name": "outputClassification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      },
      {
        "id": null,
        "parentId": "RegressionBasedUnmixing",
        "name": "outputFraction",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "regressor",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Scikit-Learn Python code specifying a regressor.",
        "label": "regressor",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1000,
        "description": "Number of mixtures per class.",
        "label": "n",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "background",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Proportion of background mixtures.",
        "label": "background",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "includeEndmember",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to include the original library spectra into the dataset.",
        "label": "includeEndmember",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "mixingProbabilities",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "0.5, 0.5",
        "description": "A list of probabilities for using 2, 3, 4, ... endmember mixing models. Trailing 0 probabilities can be skipped. The default values of 0.5, 0.5,results in 50% 2-endmember and 50% 3-endmember models.",
        "label": "mixingProbabilities",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "allowWithinClassMixtures",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to allow mixtures with profiles belonging to the same class.",
        "label": "allowWithinClassMixtures",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "classProbabilities",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "A list of probabilities for drawing profiles from each class. If not specified, class probabilities are proportional to the class size.",
        "label": "classProbabilities",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "ensembleSize",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1,
        "description": "Number of individual runs/predictions.",
        "label": "ensembleSize",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "robustFusion",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to use median and IQR (interquartile range) aggregation for ensemble decicion fusion. The default is to use mean and standard deviation.",
        "label": "robustFusion",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:RegressionbasedUnmixing\ndataset=$dataset\nraster=$raster\nregressor=$regressor\nn=$n\nbackground=$background\nincludeEndmember=$includeEndmember\nmixingProbabilities=$mixingProbabilities\nallowWithinClassMixtures=$allowWithinClassMixtures\nclassProbabilities=$classProbabilities\nensembleSize=$ensembleSize\nrobustFusion=$robustFusion\noutputFraction=$outputFraction\noutputClassification=$outputClassification\noutputFractionVariation=$outputFractionVariation"
  },
  {
    "id": "RasterizeCategorizedVectorLayer",
    "label": "Rasterize categorized vector layer",
    "version": "3.10",
    "description": "Rasterize a categorized vector layer into a categorized raster layer. Output category names and colors are given by the source layer. Resampling is done via a two-step majority voting approach. First, the categorized raster layer is resampled at x10 finer resolution, and subsequently aggregated back to the target resolution using majority voting. This approach leads to pixel-wise class decisions that are accurate to the percent.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RasterizeCategorizedVectorLayer",
        "name": "categorizedVector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      },
      {
        "id": null,
        "parentId": "RasterizeCategorizedVectorLayer",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RasterizeCategorizedVectorLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "coverage",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 50,
        "description": "Exclude all pixel where (polygon) coverage is smaller than given threshold.",
        "label": "coverage",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "majorityVoting",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": true,
        "description": "Whether to use majority voting. Turn off to use simple nearest neighbour resampling, which is much faster, but may result in highly inaccurate class decisions.",
        "label": "majorityVoting",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      }
    ],
    "templatecontents": "run\nenmapbox:rasterizeCategorizedVectorLayer\ncategorizedVector=$categorizedVector\ngrid=$grid\ncoverage=$coverage\nmajorityVoting=$majorityVoting\noutputRasterizedCategories=$outputRasterizedCategories"
  },
  {
    "id": "RasterizeVectorLayer",
    "label": "Rasterize vector layer",
    "version": "3.10",
    "description": "Converts vector geometries (points, lines and polygons) into a raster grid.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RasterizeVectorLayer",
        "name": "vector",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR"
        }
      },
      {
        "id": null,
        "parentId": "RasterizeVectorLayer",
        "name": "grid",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RasterizeVectorLayer",
        "name": "outputRaster",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "VECTOR",
          "location": "output.tif"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "initValue",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Pre-initialization value for the output raster layer.",
        "label": "initValue",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "burnValue",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 1,
        "description": "Fixed value to burn into each pixel, which is touched (point, line) or where the center is covered (polygon) by a geometry.",
        "label": "burnValue",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "burnAttribute",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Numeric vector field to use as burn values.<br/>Acceptable values:<br/> - The name of an existing field<br/> - ; delimited list of existing field names",
        "label": "burnAttribute",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "burnFid",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to use the feature ID as burn values. Initial value is set to -1. Data type is set to Int32.",
        "label": "burnFid",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "addValue",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Whether to add up existing values instead of replacing them.",
        "label": "addValue",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "allTouched",
        "type": "REGULAR",
        "dataType": "bool",
        "defaultValue": false,
        "description": "Enables the ALL_TOUCHED rasterization option so that all pixels touched by lines or polygons will be updated, not just those on the line render path, or whose center point is within the polygon.",
        "label": "allTouched",
        "notNull": false,
        "valueSet": [
          true,
          false
        ]
      },
      {
        "id": "dataType",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": "5",
        "description": "Output data type.<br/>Available values:<br/> - 0: Byte<br/> - 1: Int16<br/> - 2: UInt16<br/> - 3: UInt32<br/> - 4: Int32<br/> - 5: Float32<br/> - 6: Float64<br/> Acceptable values:<br/> - Number of selected option, e.g. '1'<br/> - Comma separated list of options, e.g. '1,3'",
        "label": "dataType",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:rasterizeVectorLayer\nvector=$vector\ngrid=$grid\ninitValue=$initValue\nburnValue=$burnValue\nburnAttribute=$burnAttribute\nburnFid=$burnFid\naddValue=$addValue\nallTouched=$allTouched\ndataType=$dataType\noutputRasterizedVector=$outputRasterizedVector"
  },
  {
    "id": "RandomPointsFromCategorizedRasterLayer",
    "label": "Random points from categorized raster layer",
    "version": "3.10",
    "description": "This algorithm creates a new point layer with a given number of random points, all of them within the categories of the given categorized raster layer.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RandomPointsFromCategorizedRasterLayer",
        "name": "stratification",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RandomPointsFromCategorizedRasterLayer",
        "name": "outputPoints",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.gpkg"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "string",
        "defaultValue": null,
        "description": "Number of points to draw from each category. Set a single value N to draw N points for each category. Set a list of values N1, N2, ... Ni, ... to draw Ni points for category i.",
        "label": "n",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "distanceGlobal",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "A minimum (Euclidean) distance between points can be specified.",
        "label": "distanceGlobal",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "distanceStatum",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "A minimum (Euclidean) distance between points in a category can be specified.",
        "label": "distanceStatum",
        "notNull": true,
        "valueSet": []
      },
      {
        "id": "seed",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "The seed for the random generator can be provided.",
        "label": "seed",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RandomPointsFromCategorizedRasterLayer\nstratification=$stratification\nn=$n\ndistanceGlobal=$distanceGlobal\ndistanceStatum=$distanceStatum\nseed=$seed\noutputPoints=$outputPoints"
  },
  {
    "id": "RandomPointsFromMaskRasterLayer",
    "label": "Random points from mask raster layer",
    "version": "3.10",
    "description": "This algorithm creates a new point layer with a given number of random points, all of them in the area where the given mask evaluates to true.",
    "authors": "Andreas Janz, Benjamin Jakimow, Fabian Thiel, Sebastian van der Linden, Patrick Hostert",
    "copyright": "C 2018-2022",
    "nodeAffinity": "Any",
    "category": "OPTICAL",
    "sources": [
      {
        "id": null,
        "parentId": "RandomPointsFromMaskRasterLayer",
        "name": "mask",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER"
        }
      }
    ],
    "targets": [
      {
        "id": null,
        "parentId": "RandomPointsFromMaskRasterLayer",
        "name": "outputPoints",
        "cardinality": 1,
        "dataDescriptor": {
          "formatType": "RASTER",
          "location": "output.gpkg"
        }
      }
    ],
    "containerId": "84931b6b-eac7-4542-9be6-f4ec0f052b23",
    "fileLocation": "qgis_process",
    "workingDirectory": ".",
    "templateType": "VELOCITY",
    "multiThread": false,
    "parallelism": 1,
    "visibility": "SYSTEM",
    "active": true,
    "parameterDescriptors": [
      {
        "id": "n",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "Number of points to be drawn.",
        "label": "n",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "distance",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "A minimum distance between points can be specified. A point will not be added if there is an already generated point within this (Euclidean) distance from the generated location.",
        "label": "distance",
        "notNull": false,
        "valueSet": []
      },
      {
        "id": "seed",
        "type": "REGULAR",
        "dataType": "int",
        "defaultValue": 0,
        "description": "The seed for the random generator can be provided.",
        "label": "seed",
        "notNull": false,
        "valueSet": []
      }
    ],
    "templatecontents": "run\nenmapbox:RandomPointsFromMaskRasterLayer\nmask=$mask\nn=$n\ndistance=$distance\nseed=$seed\noutputPoints=$outputPoints"
  }
]
